<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bild von Hand freistellen - Herzfabrik</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: #f5f5f5;
      padding: 20px;
      color: #000;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: #fff;
      border-radius: 8px;
      padding: 24px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    h1 {
      font-size: 24px;
      margin-bottom: 24px;
      color: #000;
    }
    .controls {
      margin-bottom: 20px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    button {
      padding: 10px 20px;
      border: 1px solid #ccc;
      background: #fff;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      color: #000;
    }
    button:hover {
      background: #f0f0f0;
    }
    button.primary {
      background: #666;
      color: #fff;
      border-color: #666;
    }
    button.primary:hover {
      background: #555;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .canvas-container {
      display: flex;
      gap: 24px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    .canvas-wrapper {
      flex: 1;
      min-width: 300px;
    }
    .canvas-wrapper h2 {
      font-size: 16px;
      margin-bottom: 12px;
      color: #000;
    }
    canvas {
      border: 2px solid #ddd;
      border-radius: 4px;
      cursor: crosshair;
      max-width: 100%;
      height: auto;
      display: block;
      background: #fafafa;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    .instructions {
      background: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 20px;
      color: #333;
    }
    .instructions h3 {
      font-size: 14px;
      margin-bottom: 8px;
      color: #000;
    }
    .instructions p {
      font-size: 13px;
      line-height: 1.5;
      color: #666;
    }
    .error {
      background: #fff5f5;
      border: 1px solid #f2c6c6;
      color: #8a1f1f;
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 20px;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }
    #zoomCanvas {
      z-index: 10;
    }
    @media (max-width: 768px) {
      .canvas-container {
        flex-direction: column;
      }
      .canvas-wrapper {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Bild von Hand freistellen</h1>
    
    <div id="error" class="error hidden"></div>
    <div id="loading" class="loading">Bild wird geladen...</div>
    
    <div id="main-content" class="hidden">
      <div class="instructions">
        <h3>Anleitung:</h3>
        <p>Klicken Sie auf das Originalbild, um die 4 Ecken des Gemäldes zu markieren. Die Punkte werden in dieser Reihenfolge gesetzt: oben links, oben rechts, unten rechts, unten links. Sie können die Punkte auch per Drag & Drop verschieben. Die Vorschau zeigt das Ergebnis der Extraktion.</p>
      </div>
      
      <div class="controls">
        <button id="resetBtn">Punkte zurücksetzen</button>
        <button id="saveBtn" class="primary">Speichern</button>
        <button onclick="window.location.href='index.html'">Zurück zur Übersicht</button>
      </div>
      
      <div class="canvas-container">
        <div class="canvas-wrapper">
          <h2>Originalbild</h2>
          <canvas id="sourceCanvas"></canvas>
        </div>
        <div class="canvas-wrapper">
          <h2>Vorschau</h2>
          <div class="pos-relative inline-block">
            <canvas id="previewCanvas"></canvas>
            <canvas id="zoomCanvas" class="pos-absolute pointer-events-none hidden border-2 border-gray-800 shadow-lg bg-white"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const paintingBase = urlParams.get('painting');
    
    if (!paintingBase) {
      document.getElementById('error').textContent = 'Kein Gemälde angegeben.';
      document.getElementById('error').style.display = 'block';
      document.getElementById('loading').style.display = 'none';
      throw new Error('No painting parameter');
    }

    const sourceCanvas = document.getElementById('sourceCanvas');
    const previewCanvas = document.getElementById('previewCanvas');
    const zoomCanvas = document.getElementById('zoomCanvas');
    const sourceCtx = sourceCanvas.getContext('2d');
    const previewCtx = previewCanvas.getContext('2d');
    const zoomCtx = zoomCanvas.getContext('2d');
    
    let sourceImage = null;
    let corners = [
      { x: 0, y: 0 }, // top-left
      { x: 0, y: 0 }, // top-right
      { x: 0, y: 0 }, // bottom-right
      { x: 0, y: 0 }  // bottom-left
    ];
    let currentCornerIndex = 0;
    let draggedCorner = null;
    let isDragging = false;
    let savedCorners = null;
    let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    let mouseX = -1;
    let mouseY = -1;
    const zoomLevel = 8; // 8x magnification
    const zoomSize = 200; // Size of the magnifying glass in pixels

    // Convert centimeters to pixels
    // Standard CSS reference: 1 inch = 96 pixels, 1 inch = 2.54 cm
    // So 1 cm = 96 / 2.54 ≈ 37.795 pixels
    function cmToPixels(cm) {
      const pixelsPerInch = 96; // CSS standard
      const cmPerInch = 2.54;
      return (cm * pixelsPerInch) / cmPerInch;
    }

    // Load metadata to get saved corners and offset
    async function loadMetadata() {
      try {
        const metaUrl = `images/${paintingBase}_original.jpg.json?t=${Date.now()}`;
        const response = await fetch(metaUrl);
        if (response.ok) {
          const meta = await response.json();
          if (meta.manual_corners && Array.isArray(meta.manual_corners) && meta.manual_corners.length === 4) {
            savedCorners = meta.manual_corners;
          }
        }
      } catch (error) {
        // Silently fail if metadata doesn't exist
        console.log('No saved corners found');
      }
    }

    // Calculate aspect ratio from corners
    function calculateAspectRatio(corners) {
      // Calculate average width (top and bottom edges)
      const topWidth = Math.sqrt(
        Math.pow(corners[1].x - corners[0].x, 2) + 
        Math.pow(corners[1].y - corners[0].y, 2)
      );
      const bottomWidth = Math.sqrt(
        Math.pow(corners[2].x - corners[3].x, 2) + 
        Math.pow(corners[2].y - corners[3].y, 2)
      );
      const avgWidth = (topWidth + bottomWidth) / 2;
      
      // Calculate average height (left and right edges)
      const leftHeight = Math.sqrt(
        Math.pow(corners[3].x - corners[0].x, 2) + 
        Math.pow(corners[3].y - corners[0].y, 2)
      );
      const rightHeight = Math.sqrt(
        Math.pow(corners[2].x - corners[1].x, 2) + 
        Math.pow(corners[2].y - corners[1].y, 2)
      );
      const avgHeight = (leftHeight + rightHeight) / 2;
      
      return { width: avgWidth, height: avgHeight };
    }

    // Load original image
    const originalImageUrl = `images/${paintingBase}_original.jpg`;
    const img = new Image();
    img.crossOrigin = 'anonymous';
    
    img.onload = async function() {
      sourceImage = img;
      
      // Load saved corners if available
      await loadMetadata();
      
      // Set canvas sizes
      const maxWidth = 800;
      const maxHeight = 600;
      let scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);
      
      sourceCanvas.width = img.width * scale;
      sourceCanvas.height = img.height * scale;
      
      // Draw image on source canvas
      sourceCtx.drawImage(img, 0, 0, sourceCanvas.width, sourceCanvas.height);
      
      // Initialize corners
      if (savedCorners) {
        // Scale saved corners from original image coordinates to canvas coordinates
        const scaleX = sourceCanvas.width / img.width;
        const scaleY = sourceCanvas.height / img.height;
        corners[0] = { x: savedCorners[0][0] * scaleX, y: savedCorners[0][1] * scaleY };
        corners[1] = { x: savedCorners[1][0] * scaleX, y: savedCorners[1][1] * scaleY };
        corners[2] = { x: savedCorners[2][0] * scaleX, y: savedCorners[2][1] * scaleY };
        corners[3] = { x: savedCorners[3][0] * scaleX, y: savedCorners[3][1] * scaleY };
      } else {
        // Initialize corners to image corners
        corners[0] = { x: 0, y: 0 }; // top-left
        corners[1] = { x: sourceCanvas.width, y: 0 }; // top-right
        corners[2] = { x: sourceCanvas.width, y: sourceCanvas.height }; // bottom-right
        corners[3] = { x: 0, y: sourceCanvas.height }; // bottom-left
      }
      
      updatePreview();
      drawCorners();
      
      document.getElementById('loading').style.display = 'none';
      document.getElementById('main-content').style.display = 'block';
    };
    
    img.onerror = function() {
      document.getElementById('error').textContent = 'Fehler beim Laden des Bildes. Stellen Sie sicher, dass die Datei existiert.';
      document.getElementById('error').style.display = 'block';
      document.getElementById('loading').style.display = 'none';
    };
    
    img.src = originalImageUrl + '?t=' + Date.now();

    function getOffsetCornerPosition(cornerIndex) {
      // Use larger offset on touch devices (3cm) vs desktop (1cm)
      const offsetCm = isTouchDevice ? 3 : 1;
      const offset = cmToPixels(offsetCm);
      const corner = corners[cornerIndex];
      
      // Offset each corner inward
      switch(cornerIndex) {
        case 0: // Top-left: move right and down
          return { x: corner.x + offset, y: corner.y + offset };
        case 1: // Top-right: move left and down
          return { x: corner.x - offset, y: corner.y + offset };
        case 2: // Bottom-right: move left and up
          return { x: corner.x - offset, y: corner.y - offset };
        case 3: // Bottom-left: move right and up
          return { x: corner.x + offset, y: corner.y - offset };
        default:
          return corner;
      }
    }

    function getCornerFromOffsetPosition(cornerIndex, offsetX, offsetY) {
      // Use larger offset on touch devices (3cm) vs desktop (1cm)
      const offsetCm = isTouchDevice ? 3 : 1;
      const offset = cmToPixels(offsetCm);
      
      // Reverse the offset to get the actual corner position from the circle position
      switch(cornerIndex) {
        case 0: // Top-left: circle is offset right and down, so corner is left and up
          return { x: offsetX - offset, y: offsetY - offset };
        case 1: // Top-right: circle is offset left and down, so corner is right and up
          return { x: offsetX + offset, y: offsetY - offset };
        case 2: // Bottom-right: circle is offset left and up, so corner is right and down
          return { x: offsetX + offset, y: offsetY + offset };
        case 3: // Bottom-left: circle is offset right and up, so corner is left and down
          return { x: offsetX - offset, y: offsetY + offset };
        default:
          return { x: offsetX, y: offsetY };
      }
    }

    function drawCorners() {
      if (!sourceImage) return;
      
      // Redraw image
      sourceCtx.clearRect(0, 0, sourceCanvas.width, sourceCanvas.height);
      sourceCtx.drawImage(sourceImage, 0, 0, sourceCanvas.width, sourceCanvas.height);
      
      // Draw quadrilateral
      sourceCtx.strokeStyle = '#00ff00';
      sourceCtx.lineWidth = 2;
      sourceCtx.beginPath();
      sourceCtx.moveTo(corners[0].x, corners[0].y);
      for (let i = 1; i < 4; i++) {
        sourceCtx.lineTo(corners[i].x, corners[i].y);
      }
      sourceCtx.closePath();
      sourceCtx.stroke();
      
      // Draw lines from circles to corner points
      corners.forEach((corner, index) => {
        const offsetPos = getOffsetCornerPosition(index);
        sourceCtx.strokeStyle = '#00ff00';
        sourceCtx.lineWidth = 1;
        sourceCtx.beginPath();
        sourceCtx.moveTo(offsetPos.x, offsetPos.y);
        sourceCtx.lineTo(corner.x, corner.y);
        sourceCtx.stroke();
      });
      
      // Draw corner points at offset positions
      const pointRadius = 8;
      corners.forEach((corner, index) => {
        const offsetPos = getOffsetCornerPosition(index);
        sourceCtx.fillStyle = index === currentCornerIndex ? '#ff0000' : '#00ff00';
        sourceCtx.beginPath();
        sourceCtx.arc(offsetPos.x, offsetPos.y, pointRadius, 0, Math.PI * 2);
        sourceCtx.fill();
        sourceCtx.strokeStyle = '#fff';
        sourceCtx.lineWidth = 2;
        sourceCtx.stroke();
      });
    }

    function updatePreview() {
      if (!sourceImage) return;
      
      // Calculate source coordinates (in original image dimensions)
      const scaleX = sourceImage.width / sourceCanvas.width;
      const scaleY = sourceImage.height / sourceCanvas.height;
      
      const srcCorners = corners.map(c => ({
        x: c.x * scaleX,
        y: c.y * scaleY
      }));
      
      // Calculate aspect ratio from corners
      const aspectRatio = calculateAspectRatio(srcCorners);
      
      // Set preview canvas size based on calculated aspect ratio
      // Scale to fit within max dimensions while maintaining aspect ratio
      const maxPreviewWidth = 800;
      const maxPreviewHeight = 600;
      let previewScale = Math.min(maxPreviewWidth / aspectRatio.width, maxPreviewHeight / aspectRatio.height, 1);
      
      const previewWidth = Math.round(aspectRatio.width * previewScale);
      const previewHeight = Math.round(aspectRatio.height * previewScale);
      
      // Only resize if dimensions changed to avoid unnecessary redraws
      if (previewCanvas.width !== previewWidth || previewCanvas.height !== previewHeight) {
        previewCanvas.width = previewWidth;
        previewCanvas.height = previewHeight;
      }
      
      // Create temporary canvas for perspective transformation
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = sourceImage.width;
      tempCanvas.height = sourceImage.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      // Draw source image
      tempCtx.drawImage(sourceImage, 0, 0);
      
      // Get image data
      const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
      
      // Create output image data
      const outputData = previewCtx.createImageData(previewCanvas.width, previewCanvas.height);
      
      // Perform perspective transformation
      // Using bilinear interpolation for better quality
      for (let y = 0; y < previewCanvas.height; y++) {
        for (let x = 0; x < previewCanvas.width; x++) {
          // Normalized coordinates in destination (0-1)
          const u = x / previewCanvas.width;
          const v = y / previewCanvas.height;
          
          // Calculate corresponding point in source using bilinear interpolation
          // Top edge
          const topX = srcCorners[0].x + (srcCorners[1].x - srcCorners[0].x) * u;
          const topY = srcCorners[0].y + (srcCorners[1].y - srcCorners[0].y) * u;
          
          // Bottom edge
          const bottomX = srcCorners[3].x + (srcCorners[2].x - srcCorners[3].x) * u;
          const bottomY = srcCorners[3].y + (srcCorners[2].y - srcCorners[3].y) * u;
          
          // Interpolate between top and bottom
          const srcX = topX + (bottomX - topX) * v;
          const srcY = topY + (bottomY - topY) * v;
          
          // Get pixel from source
          const srcPixelX = Math.floor(srcX);
          const srcPixelY = Math.floor(srcY);
          
          if (srcPixelX >= 0 && srcPixelX < tempCanvas.width && srcPixelY >= 0 && srcPixelY < tempCanvas.height) {
            const srcIndex = (srcPixelY * tempCanvas.width + srcPixelX) * 4;
            const dstIndex = (y * previewCanvas.width + x) * 4;
            
            outputData.data[dstIndex] = imageData.data[srcIndex];
            outputData.data[dstIndex + 1] = imageData.data[srcIndex + 1];
            outputData.data[dstIndex + 2] = imageData.data[srcIndex + 2];
            outputData.data[dstIndex + 3] = imageData.data[srcIndex + 3];
          }
        }
      }
      
      previewCtx.putImageData(outputData, 0, 0);
      
      // Update zoom if mouse is over preview
      if (mouseX >= 0 && mouseY >= 0) {
        drawZoom(mouseX, mouseY);
      }
    }

    function getPreviewCanvasCoordinates(e) {
      const rect = previewCanvas.getBoundingClientRect();
      let clientX, clientY;
      
      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      
      const scaleX = previewCanvas.width / rect.width;
      const scaleY = previewCanvas.height / rect.height;
      
      return {
        x: x * scaleX,
        y: y * scaleY
      };
    }

    function drawZoom(mouseX, mouseY) {
      if (mouseX < 0 || mouseY < 0 || !previewCanvas.width || !previewCanvas.height) {
        zoomCanvas.style.display = 'none';
        return;
      }
      
      const rect = previewCanvas.getBoundingClientRect();
      const zoomRadius = zoomSize / 2;
      const sourceRadius = zoomRadius / zoomLevel;
      
      // Calculate source coordinates in preview canvas
      const sourceX = Math.max(sourceRadius, Math.min(previewCanvas.width - sourceRadius, mouseX));
      const sourceY = Math.max(sourceRadius, Math.min(previewCanvas.height - sourceRadius, mouseY));
      
      // Set zoom canvas size
      zoomCanvas.width = zoomSize;
      zoomCanvas.height = zoomSize;
      
      // Clear and draw zoomed area
      zoomCtx.clearRect(0, 0, zoomSize, zoomSize);
      
      // Draw the zoomed image
      zoomCtx.imageSmoothingEnabled = false; // Pixel-perfect rendering
      zoomCtx.drawImage(
        previewCanvas,
        sourceX - sourceRadius, sourceY - sourceRadius, // Source position
        sourceRadius * 2, sourceRadius * 2, // Source size
        0, 0, // Destination position
        zoomSize, zoomSize // Destination size
      );
      
      // Draw pixel grid
      zoomCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
      zoomCtx.lineWidth = 0.5;
      const pixelSize = zoomSize / (sourceRadius * 2);
      const centerX = zoomSize / 2;
      const centerY = zoomSize / 2;
      
      // Draw grid lines
      for (let i = -sourceRadius; i <= sourceRadius; i++) {
        const pos = centerX + i * pixelSize;
        zoomCtx.beginPath();
        zoomCtx.moveTo(pos, 0);
        zoomCtx.lineTo(pos, zoomSize);
        zoomCtx.stroke();
        
        zoomCtx.beginPath();
        zoomCtx.moveTo(0, pos);
        zoomCtx.lineTo(zoomSize, pos);
        zoomCtx.stroke();
      }
      
      // Draw center crosshair
      zoomCtx.strokeStyle = '#ff0000';
      zoomCtx.lineWidth = 1;
      zoomCtx.beginPath();
      zoomCtx.moveTo(centerX - 10, centerY);
      zoomCtx.lineTo(centerX + 10, centerY);
      zoomCtx.moveTo(centerX, centerY - 10);
      zoomCtx.lineTo(centerX, centerY + 10);
      zoomCtx.stroke();
      
      // Draw border
      zoomCtx.strokeStyle = '#333';
      zoomCtx.lineWidth = 2;
      zoomCtx.strokeRect(0, 0, zoomSize, zoomSize);
      
      // Position zoom canvas near mouse cursor
      const canvasX = rect.left + (sourceX / (previewCanvas.width / rect.width)) - zoomRadius;
      const canvasY = rect.top + (sourceY / (previewCanvas.height / rect.height)) - zoomRadius;
      
      // Adjust position to keep it within viewport
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      let finalX = canvasX;
      let finalY = canvasY;
      
      if (finalX + zoomSize > viewportWidth) {
        finalX = viewportWidth - zoomSize - 10;
      }
      if (finalX < 0) {
        finalX = 10;
      }
      if (finalY + zoomSize > viewportHeight) {
        finalY = viewportHeight - zoomSize - 10;
      }
      if (finalY < 0) {
        finalY = 10;
      }
      
      zoomCanvas.style.left = finalX + 'px';
      zoomCanvas.style.top = finalY + 'px';
      zoomCanvas.style.display = 'block';
    }

    function getCornerAt(x, y, isTouch = false) {
      let closestIndex = -1;
      let closestDist = Infinity;
      // Match the visual circle radius (8px) with a small buffer
      const mouseThreshold = 12;
      
      // Always check all 4 corners (check against offset positions for hit detection)
      for (let i = 0; i < corners.length; i++) {
        const offsetPos = getOffsetCornerPosition(i);
        const dx = offsetPos.x - x;
        const dy = offsetPos.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (isTouch) {
          // For touch: always find the closest corner, regardless of distance
          if (dist < closestDist) {
            closestDist = dist;
            closestIndex = i;
          }
        } else {
          // For mouse: only consider corners within threshold (matching visual circle size)
          if (dist < mouseThreshold && dist < closestDist) {
            closestDist = dist;
            closestIndex = i;
          }
        }
      }
      
      // For touch, always return the closest corner (even if far away)
      // For mouse, only return if within threshold (closestDist must be < mouseThreshold)
      if (isTouch) {
        return closestIndex;
      } else {
        // Only return corner if it's actually within the threshold
        return closestDist < mouseThreshold ? closestIndex : -1;
      }
    }

    function getCanvasCoordinates(e) {
      const rect = sourceCanvas.getBoundingClientRect();
      let clientX, clientY;
      let isTouch = false;
      
      if (e.touches && e.touches.length > 0) {
        // Touch event
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
        isTouch = true;
      } else {
        // Mouse event
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      // Get coordinates relative to the canvas element
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      
      // Calculate scale factor between displayed size and actual canvas size
      const scaleX = sourceCanvas.width / rect.width;
      const scaleY = sourceCanvas.height / rect.height;
      
      // Scale coordinates to match canvas internal dimensions
      return {
        x: x * scaleX,
        y: y * scaleY,
        isTouch: isTouch
      };
    }

    function handlePointerDown(x, y, isTouch = false) {
      const cornerIndex = getCornerAt(x, y, isTouch);
      if (cornerIndex !== -1) {
        draggedCorner = cornerIndex;
        isDragging = true;
        currentCornerIndex = cornerIndex;
        drawCorners();
        updatePreview();
      } else if (isTouch) {
        // For touch only: Set new corner position when clicking away from corners
        corners[currentCornerIndex] = { x, y };
        currentCornerIndex = (currentCornerIndex + 1) % 4;
        drawCorners();
        updatePreview();
      }
      // For mouse: do nothing if no corner is detected (don't move corners)
    }

    function handlePointerMove(x, y, isTouch = false) {
      if (isDragging && draggedCorner !== null) {
        // Calculate actual corner position from the circle position (accounting for offset)
        const cornerPos = getCornerFromOffsetPosition(draggedCorner, x, y);
        corners[draggedCorner] = cornerPos;
        drawCorners();
        updatePreview();
      } else {
        // Change cursor if over a corner (desktop only)
        const cornerIndex = getCornerAt(x, y, isTouch);
        sourceCanvas.style.cursor = cornerIndex !== -1 ? 'move' : 'crosshair';
      }
    }

    function handlePointerUp() {
      isDragging = false;
      draggedCorner = null;
    }

    // Mouse events
    sourceCanvas.addEventListener('mousedown', (e) => {
      e.preventDefault();
      const { x, y, isTouch } = getCanvasCoordinates(e);
      handlePointerDown(x, y, isTouch);
    });

    sourceCanvas.addEventListener('mousemove', (e) => {
      const { x, y, isTouch } = getCanvasCoordinates(e);
      handlePointerMove(x, y, isTouch);
    });

    sourceCanvas.addEventListener('mouseup', (e) => {
      e.preventDefault();
      handlePointerUp();
    });

    sourceCanvas.addEventListener('mouseleave', () => {
      handlePointerUp();
    });

    // Touch events
    sourceCanvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const { x, y, isTouch } = getCanvasCoordinates(e);
      handlePointerDown(x, y, isTouch);
    }, { passive: false });

    sourceCanvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const { x, y, isTouch } = getCanvasCoordinates(e);
      handlePointerMove(x, y, isTouch);
    }, { passive: false });

    sourceCanvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      handlePointerUp();
    }, { passive: false });

    sourceCanvas.addEventListener('touchcancel', (e) => {
      e.preventDefault();
      handlePointerUp();
    }, { passive: false });

    // Zoom effect on preview canvas
    previewCanvas.addEventListener('mousemove', (e) => {
      const coords = getPreviewCanvasCoordinates(e);
      mouseX = coords.x;
      mouseY = coords.y;
      drawZoom(mouseX, mouseY);
    });

    previewCanvas.addEventListener('mouseleave', () => {
      mouseX = -1;
      mouseY = -1;
      zoomCanvas.style.display = 'none';
    });

    previewCanvas.addEventListener('mousedown', (e) => {
      const coords = getPreviewCanvasCoordinates(e);
      mouseX = coords.x;
      mouseY = coords.y;
      drawZoom(mouseX, mouseY);
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      corners[0] = { x: 0, y: 0 };
      corners[1] = { x: sourceCanvas.width, y: 0 };
      corners[2] = { x: sourceCanvas.width, y: sourceCanvas.height };
      corners[3] = { x: 0, y: sourceCanvas.height };
      currentCornerIndex = 0;
      drawCorners();
      updatePreview();
    });

    document.getElementById('saveBtn').addEventListener('click', async () => {
      const btn = document.getElementById('saveBtn');
      btn.disabled = true;
      btn.textContent = 'Speichere...';
      
      try {
        // Calculate source corners in original image coordinates
        const scaleX = sourceImage.width / sourceCanvas.width;
        const scaleY = sourceImage.height / sourceCanvas.height;
        
        const srcCorners = corners.map(c => ({
          x: c.x * scaleX,
          y: c.y * scaleY
        }));
        
        // Calculate aspect ratio from corners
        const aspectRatio = calculateAspectRatio(srcCorners);
        
        // Create a high-resolution canvas for the final image
        // Use calculated aspect ratio, but scale up to use full resolution
        // Determine scale factor to maximize resolution while maintaining aspect ratio
        const maxDimension = Math.max(sourceImage.width, sourceImage.height);
        const scaleFactor = Math.min(maxDimension / aspectRatio.width, maxDimension / aspectRatio.height);
        
        const finalCanvas = document.createElement('canvas');
        finalCanvas.width = Math.round(aspectRatio.width * scaleFactor);
        finalCanvas.height = Math.round(aspectRatio.height * scaleFactor);
        const finalCtx = finalCanvas.getContext('2d');
        
        // Create temporary canvas with source image
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = sourceImage.width;
        tempCanvas.height = sourceImage.height;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Draw source image
        tempCtx.drawImage(sourceImage, 0, 0);
        
        // Get image data
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        
        // Create output image data
        const outputData = finalCtx.createImageData(finalCanvas.width, finalCanvas.height);
        
        // Perform perspective transformation
        for (let y = 0; y < finalCanvas.height; y++) {
          for (let x = 0; x < finalCanvas.width; x++) {
            const u = x / finalCanvas.width;
            const v = y / finalCanvas.height;
            
            const topX = srcCorners[0].x + (srcCorners[1].x - srcCorners[0].x) * u;
            const topY = srcCorners[0].y + (srcCorners[1].y - srcCorners[0].y) * u;
            
            const bottomX = srcCorners[3].x + (srcCorners[2].x - srcCorners[3].x) * u;
            const bottomY = srcCorners[3].y + (srcCorners[2].y - srcCorners[3].y) * u;
            
            const srcX = topX + (bottomX - topX) * v;
            const srcY = topY + (bottomY - topY) * v;
            
            const srcPixelX = Math.floor(srcX);
            const srcPixelY = Math.floor(srcY);
            
            if (srcPixelX >= 0 && srcPixelX < tempCanvas.width && srcPixelY >= 0 && srcPixelY < tempCanvas.height) {
              const srcIndex = (srcPixelY * tempCanvas.width + srcPixelX) * 4;
              const dstIndex = (y * finalCanvas.width + x) * 4;
              
              outputData.data[dstIndex] = imageData.data[srcIndex];
              outputData.data[dstIndex + 1] = imageData.data[srcIndex + 1];
              outputData.data[dstIndex + 2] = imageData.data[srcIndex + 2];
              outputData.data[dstIndex + 3] = imageData.data[srcIndex + 3];
            }
          }
        }
        
        finalCtx.putImageData(outputData, 0, 0);
        
        // Convert to blob and send as base64 (avoids upload_max_filesize issues)
        finalCanvas.toBlob(async (blob) => {
          if (!blob) {
            throw new Error('Fehler beim Erstellen des Bildes');
          }
          
          // Prepare corner positions (in original image coordinates)
          const cornerPositions = srcCorners.map(c => [Math.round(c.x), Math.round(c.y)]);
          
          // Convert blob to base64 and send directly (avoids PHP upload_max_filesize limit)
          const reader = new FileReader();
          reader.onloadend = async () => {
            const base64data = reader.result;
            const formData = new FormData();
            formData.append('image_data', base64data);
            formData.append('base', paintingBase);
            formData.append('corners', JSON.stringify(cornerPositions));
            
            const response = await fetch('save_free.php', {
              method: 'POST',
              body: formData
            });
            
            if (!response.ok) {
              const errorText = await response.text();
              let errorData;
              try {
                errorData = JSON.parse(errorText);
              } catch (e) {
                throw new Error(errorText || 'Fehler beim Speichern');
              }
              throw new Error(errorData.error || errorData.detail || 'Fehler beim Speichern');
            }
            
            const result = await response.json();
            if (!result.ok) {
              throw new Error(result.error || 'Fehler beim Speichern');
            }
            
            alert('Bild erfolgreich gespeichert!');
            window.location.href = 'index.html';
          };
          reader.onerror = () => {
            throw new Error('Fehler beim Konvertieren des Bildes');
          };
          reader.readAsDataURL(blob);
        }, 'image/jpeg', 0.95);
      } catch (error) {
        alert('Fehler: ' + error.message);
        btn.disabled = false;
        btn.textContent = 'Speichern';
      }
    });
  </script>
</body>
</html>


