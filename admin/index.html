<!DOCTYPE html>
<html lang="en" style="color-scheme: light only;">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light">
  <title>Administration der Herzfabrik</title>
  <style>
    html { color-scheme: light; background: #fff; }
    body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; background: #fff; color: #000; }
    h1 { font-size: 20px; margin: 0 0 16px; color: #000; }
    h2 { font-size: 16px; margin: 24px 0 12px; color: #000; }
    .upload-area { border: 3px dashed #888; border-radius: 12px; padding: 32px; background: #f5f5f5; text-align: center; transition: all 0.3s ease; cursor: pointer; }
    .upload-area:hover { background: #e8e8e8; border-color: #666; }
    .upload-area.dragover { background: #ddd; border-color: #666; border-style: solid; }
    .upload-area-text { color: #555; font-weight: 500; margin-bottom: 8px; }
    .upload-area-hint { color: #666; font-size: 13px; }
    .list { display: flex; flex-direction: column; gap: 12px; }
    .rowItem { display: grid; grid-template-columns: 300px 1fr; gap: 24px; border: 1px solid #eee; border-radius: 8px; padding: 16px; align-items: start; position: relative; background: #fff; }
    .rowItem.live { border-color: #28a745; background: #f6fffa; }
    .image-container { position: relative; width: 100%; max-width: 300px; }
    .main-image-wrapper { position: relative; width: 100%; max-width: 300px; }
    .admin-frame-preview { background: #f5f5f5; padding: 12px; border-radius: 2px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.5); border: none; transition: all 0.3s ease; }
    .admin-frame-preview.frame-white { background: #f8f8f8; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12), 0 2px 4px rgba(0, 0, 0, 0.08), inset 0 0 0 1px rgba(255, 255, 255, 0.8); }
    .admin-frame-preview.frame-black { background: #1a1a1a; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.3), inset 0 0 0 1px rgba(255, 255, 255, 0.05), inset 0 1px 0 rgba(255, 255, 255, 0.08); }
    .admin-frame-preview.frame-wood { background: #c19a6b; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25), 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.15), inset 0 -1px 0 rgba(0, 0, 0, 0.25), inset 0 0 0 1px rgba(139, 111, 71, 0.3); position: relative; }
    .admin-frame-preview.frame-wood::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(ellipse at 20% 30%, rgba(139, 111, 71, 0.15) 0%, transparent 50%), radial-gradient(ellipse at 80% 70%, rgba(193, 154, 107, 0.2) 0%, transparent 50%), linear-gradient(90deg, transparent 0%, rgba(139, 111, 71, 0.08) 25%, transparent 50%, rgba(139, 111, 71, 0.08) 75%, transparent 100%); pointer-events: none; }
    .admin-frame-preview.frame-gold { background: radial-gradient(ellipse at top, rgba(255, 255, 255, 0.3) 0%, transparent 50%), linear-gradient(135deg, #f5d76e 0%, #d4af37 30%, #b8941f 60%, #d4af37 100%); border: none; box-shadow: 0 4px 12px rgba(184, 148, 31, 0.35), 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.4), inset 0 -1px 0 rgba(0, 0, 0, 0.25), inset 0 0 15px rgba(212, 175, 55, 0.2); }
    .admin-frame-preview.frame-silver { background: linear-gradient(135deg, #f0f0f0 0%, #d0d0d0 25%, #b0b0b0 50%, #d0d0d0 75%, #f0f0f0 100%), linear-gradient(45deg, rgba(255, 255, 255, 0.3) 0%, transparent 50%); border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25), 0 2px 4px rgba(0, 0, 0, 0.18), inset 0 1px 0 rgba(255, 255, 255, 0.7), inset 0 -1px 0 rgba(0, 0, 0, 0.2), inset 0 0 10px rgba(112, 112, 112, 0.1); }
    .admin-frame-preview.frame-walnut { background: #5c4033; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), 0 2px 4px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.08), inset 0 -1px 0 rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(61, 42, 34, 0.4); position: relative; }
    .admin-frame-preview.frame-walnut::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(ellipse at 25% 40%, rgba(61, 42, 34, 0.2) 0%, transparent 45%), radial-gradient(ellipse at 75% 60%, rgba(92, 64, 51, 0.15) 0%, transparent 45%), linear-gradient(90deg, transparent 0%, rgba(61, 42, 34, 0.1) 30%, transparent 60%, rgba(61, 42, 34, 0.1) 100%); pointer-events: none; }
    .admin-frame-preview.frame-oak { background: #d4a574; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.22), 0 2px 4px rgba(0, 0, 0, 0.18), inset 0 1px 0 rgba(255, 255, 255, 0.2), inset 0 -1px 0 rgba(0, 0, 0, 0.2), inset 0 0 0 1px rgba(184, 150, 106, 0.25); position: relative; }
    .admin-frame-preview.frame-oak::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(ellipse at 30% 25%, rgba(184, 150, 106, 0.12) 0%, transparent 50%), radial-gradient(ellipse at 70% 75%, rgba(212, 165, 116, 0.15) 0%, transparent 50%), linear-gradient(90deg, transparent 0%, rgba(184, 150, 106, 0.06) 35%, transparent 65%, rgba(184, 150, 106, 0.06) 100%); pointer-events: none; }
    .admin-frame-preview.frame-ornate-gold { background: radial-gradient(ellipse at 30% 30%, rgba(255, 255, 255, 0.4) 0%, transparent 40%), radial-gradient(ellipse at 70% 70%, rgba(0, 0, 0, 0.1) 0%, transparent 40%), linear-gradient(135deg, #ffd700 0%, #ffed4e 20%, #d4af37 40%, #b8941f 60%, #d4af37 80%, #ffd700 100%); border: none; box-shadow: 0 4px 12px rgba(184, 148, 31, 0.4), 0 2px 4px rgba(0, 0, 0, 0.25), inset 0 2px 0 rgba(255, 255, 255, 0.5), inset 0 -2px 0 rgba(0, 0, 0, 0.3), inset 0 0 20px rgba(212, 175, 55, 0.25), 0 0 0 1px rgba(157, 122, 26, 0.3); }
    .admin-frame-preview.frame-natural { background: #f5f0e8; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.08), inset 0 0 0 1px rgba(255, 255, 255, 0.9), inset 0 1px 2px rgba(0, 0, 0, 0.05); }
    .admin-frame-preview.frame-none { background: transparent; padding: 0; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1); }
    .admin-frame-preview .main-image { width: 100%; display: block; }
    .live-badge { position: absolute; top: 12px; left: 12px; background: #28a745; color: #fff; padding: 8px 16px; border-radius: 12px; font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; z-index: 100; }
    .live-badge.clickable { cursor: pointer; transition: all 0.2s ease; }
    .live-badge.clickable:hover { background: #218838; transform: scale(1.05); }
    .draft-badge { position: absolute; top: 12px; left: 12px; background: #ffc107; color: #000; padding: 8px 16px; border-radius: 12px; font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; z-index: 100; }
    .draft-badge.clickable { cursor: pointer; transition: all 0.2s ease; }
    .draft-badge.clickable:hover { background: #e0a800; transform: scale(1.05); }
    .main-image { width: 100%; max-width: 300px; border-radius: 0; background: #fafafa; position: relative; }
    .main-image.clickable { cursor: pointer; transition: opacity 0.2s ease; }
    .main-image.clickable:hover { opacity: 0.9; }
    .delete-icon { width: 32px; height: 32px; border-radius: 50%; background: #dc3545; color: #fff; border: 2px solid #dc3545; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; line-height: 1; padding: 0; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3); }
    .delete-icon:hover { background: #c82333; border-color: #c82333; transform: scale(1.1); box-shadow: 0 4px 8px rgba(220, 53, 69, 0.5); }
    .form-container { position: relative;  }
    .ai-fill-button { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; display: inline-flex; align-items: center; gap: 8px; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3); margin-bottom: 16px; white-space: nowrap; overflow: hidden; }
    .ai-fill-button:hover { transform: translateY(-1px); box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4); }
    .ai-fill-button:active { transform: translateY(0); }
    .ai-fill-button .star-icon { font-size: 16px; flex-shrink: 0; }
    .ai-fill-button .short-text { display: inline-block; }
    .ai-fill-button .full-text { display: inline-block; max-width: 0; opacity: 0; overflow: hidden; transition: max-width 0.3s ease, opacity 0.3s ease; }
    .ai-fill-button:hover .short-text { display: none; }
    .ai-fill-button:hover .full-text { max-width: 300px; opacity: 1; }
    @media (hover: none) {
      .ai-fill-button .short-text { display: none; }
      .ai-fill-button .full-text { max-width: 300px; opacity: 1; }
    }
    .main-image-wrapper .segmented-button { display: flex; width: calc(100% - 24px); border: 1px solid #ccc; border-radius: 6px; overflow: hidden; background: #fff; position: absolute; bottom: 12px; left: 12px; right: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.25); z-index: 50; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; }
    .main-image-wrapper.show-segmented-button:hover .segmented-button { opacity: 1; visibility: visible; }
    @media (hover: none) {
      .main-image-wrapper.show-segmented-button .segmented-button { opacity: 1; visibility: visible; }
    }
    .segmented-button-section { flex: 1; padding: 10px 12px; text-align: center; border-right: 1px solid #ccc; cursor: pointer; transition: all 0.2s ease; font-size: 13px; background: #fff; color: #000; }
    .segmented-button-section:last-child { border-right: none; }
    .segmented-button-section:hover { background: #f5f5f5; }
    .segmented-button-section:active { background: #e8e8e8; }
    .segmented-button-section.loading { opacity: 0.6; cursor: wait; pointer-events: none; }
    .segmented-button-section.ai-style { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; font-weight: 600; border-right-color: rgba(255, 255, 255, 0.3); }
    .segmented-button-section.ai-style:hover { background: linear-gradient(135deg, #5568d3 0%, #653a8f 100%); }
    .segmented-button-section.ai-style .star-icon { font-size: 14px; margin-right: 4px; display: inline-block; }
    .selectable-variants-title { font-size: 12px; color: #ffffff !important; margin-bottom: 8px; font-weight: 600; padding: 6px 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 4px; display: inline-flex; align-items: center; gap: 6px; }
    .selectable-variants-title .star-icon { font-size: 14px; color: #ffffff; }
    .selectable-variant-thumb { width: 60px; height: 60px; object-fit: cover; border-radius: 4px; background: #fafafa; cursor: pointer; border: 2px solid #667eea; transition: all 0.2s; }
    .selectable-variant-thumb:hover { border-color: #764ba2; transform: scale(1.05); box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4); }
    
    /* Responsive design */
    @media (max-width: 1024px) {
      body { margin: 12px; }
      .rowItem { grid-template-columns: 1fr; gap: 16px; }
      .main-image { max-width: 100%; }
      .btns { width: 100%; flex-direction: column; }
      .btns button { width: 100%; }
      .upload-area { padding: 24px 16px; }
      .toolbar { flex-direction: column; align-items: stretch; }
      .toolbar button { width: 100%; }
      /* Make upload sections stack vertically on smaller screens */
      .upload-sections { grid-template-columns: 1fr !important; }
    }
    
    @media (max-width: 768px) {
      body { margin: 8px; }
      h1 { font-size: 18px; }
      h2 { font-size: 14px; }
      .rowItem { padding: 12px; }
      .live-badge, .draft-badge { font-size: 10px; padding: 3px 8px; }
    }
    .variant-thumbs { display: flex; flex-wrap: nowrap; gap: 8px; margin-top: 12px; overflow-x: auto; padding-bottom: 4px; }
    .variant-thumb-wrapper { position: relative; flex-shrink: 0; }
    .variant-thumb { width: 80px; height: 80px; object-fit: cover; border-radius: 6px; background: #fafafa; cursor: pointer; border: 2px solid transparent; display: block; }
    .variant-thumb:hover { border-color: #888; }
    .variant-thumb.active { border-color: #666; }
    .variant-thumb-delete { position: absolute; top: 4px; right: 4px; width: 18px; height: 18px; border-radius: 50%; background: #dc3545; color: #fff; border: 1px solid #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; line-height: 1; padding: 0; z-index: 10; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    .variant-thumb-delete:hover { background: #c82333; }
    .selectable-variants { margin-top: 16px; padding-top: 16px; border-top: 1px solid #eee; display: none; }
    .selectable-variants.visible { display: block; }
    .selectable-variants-grid { display: flex; flex-wrap: wrap; gap: 6px; }
    .selectable-variant-thumb:active { transform: scale(0.95); }
    .add-variant-btn { width: 80px; height: 80px; border: 2px dashed #ccc; border-radius: 6px; background: #fafafa; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 24px; color: #999; transition: all 0.2s; flex-shrink: 0; }
    .add-variant-btn:hover { border-color: #888; color: #666; background: #f0f0f0; }
    .thumb { width: 100%; aspect-ratio: 1 / 1; object-fit: cover; border-radius: 6px; background: #fafafa; }
    .row { display: flex; align-items: center; gap: 8px; }
    button { appearance: none; border: 1px solid #ccc; background: #fff; padding: 8px 12px; border-radius: 6px; cursor: pointer; }
    button.primary { background: #666; color: #fff; border-color: #666; }
    button.primary:hover { background: #555; border-color: #555; }
    .muted { color: #666; font-size: 12px; }
    .toolbar { display: flex; gap: 8px; align-items: center; justify-content: space-between; margin-top: 8px; }
    .hidden { display: none; }
    .flash { border: 1px solid #f2c6c6; background: #fff5f5; color: #8a1f1f; padding: 12px; border-radius: 8px; margin-bottom: 16px; }
    .flash.success { border-color: #bfe1c7; background: #f6fffa; color: #1f6b3a; }
    .field { display: flex; flex-direction: column; gap: 4px; margin-bottom: 8px; }
    .field label { font-size: 12px; color: #555; }
    .field input, .field textarea { width: 100%; padding: 6px 8px; border: 1px solid #ccc; border-radius: 6px; font: inherit; background: #fff; color: #000; }
    .btns { display: flex; flex-wrap: wrap; gap: 8px; }
    .toast-container { position: fixed; top: 20px; right: 20px; z-index: 10000; display: flex; flex-direction: column; gap: 8px; }
    .toast { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 12px 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 300px; max-width: 400px; animation: toastSlideIn 0.3s ease-out; }
    .toast.success { border-color: #28a745; background: #f6fffa; color: #1f6b3a; }
    .toast.error { border-color: #dc3545; background: #fff5f5; color: #8a1f1f; }
    .toast.info { border-color: #888; background: #f5f5f5; color: #333; }
    @keyframes toastSlideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes toastSlideOut {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
    .toast.hiding { animation: toastSlideOut 0.3s ease-in forwards; }
  </style>
  <script>
    // Set admin flag in localStorage when admin page loads successfully
    if (typeof Storage !== 'undefined') {
      localStorage.setItem('admin', 'true');
    }
    
    let availableVariants = [];

    async function fetchVariants() {
      try {
        const res = await fetch('variants.php?action=list');
        if (!res.ok) return [];
        const data = await res.json();
        return data.ok ? (data.variants || []) : [];
      } catch (error) {
        console.error('Error fetching variants:', error);
        return [];
      }
    }

    async function fetchImages() {
      const res = await fetch('list_images.php');
      if (!res.ok) return { images: [] };
      return res.json();
    }

    // Auto-save debounce timers for each painting
    const autoSaveTimers = new Map();
    
    function setupAutoSave(imageBaseName, imageOriginalName) {
      const row = document.getElementById(`painting-${imageBaseName}`);
      if (!row) return;
      
      const indicator = document.getElementById(`save-indicator-${imageBaseName}`);
      
      // Get all form fields
      const fields = [
        row.querySelector('input[name="title"]'),
        row.querySelector('textarea[name="description"]'),
        row.querySelector('input[name="width"]'),
        row.querySelector('input[name="height"]'),
        row.querySelector('input[name="tags"]'),
        row.querySelector('input[name="date"]'),
        row.querySelector('input[name="sold"]'),
        row.querySelector('select[name="frame_type"]')
      ].filter(f => f !== null);
      
      // Function to trigger auto-save
      const triggerAutoSave = () => {
        // Clear existing timer
        if (autoSaveTimers.has(imageBaseName)) {
          clearTimeout(autoSaveTimers.get(imageBaseName));
        }
        
        // Show "Wird gespeichert..." indicator
        if (indicator) {
          indicator.textContent = 'Wird gespeichert...';
          indicator.style.color = '#666';
          indicator.style.opacity = '1';
        }
        
        // Set new timer (1.5 second delay)
        const timer = setTimeout(async () => {
          try {
            await saveMetaAuto(imageOriginalName, row, indicator);
          } catch (error) {
            console.error('Auto-save error:', error);
            if (indicator) {
              indicator.textContent = 'Fehler beim Speichern';
              indicator.style.color = '#dc3545';
              indicator.style.opacity = '1';
              setTimeout(() => {
                if (indicator) indicator.style.opacity = '0';
              }, 3000);
            }
          }
          autoSaveTimers.delete(imageBaseName);
        }, 1500);
        
        autoSaveTimers.set(imageBaseName, timer);
      };
      
      // Attach event listeners to all fields
      fields.forEach(field => {
        // Update URL immediately when field changes
        const updateURL = () => {
          updatePaintingURL(imageBaseName);
        };
        
        // Focus event - update URL when clicking/focusing on input
        field.addEventListener('focus', updateURL);
        
        // Input/change events
        field.addEventListener('input', () => {
          updateURL();
          triggerAutoSave();
        });
        field.addEventListener('change', () => {
          updateURL();
          triggerAutoSave();
        });
        
        // Paste event (for text fields)
        if (field.tagName === 'INPUT' || field.tagName === 'TEXTAREA') {
          field.addEventListener('paste', () => {
            // Small delay to let paste complete
            setTimeout(() => {
              updateURL();
              triggerAutoSave();
            }, 100);
          });
        }
      });
      
      // Helper function to check if target is an interactive element
      const isInteractiveElement = (target) => {
        return target.closest('button, input, textarea, a, img.clickable, .variant-thumb, .selectable-variant-thumb, .segmented-button-section, .variant-thumb-delete, .delete-icon, .ai-fill-button, .live-badge, .draft-badge, .add-variant-btn, .selectable-variants-title, label, .field');
      };
      
      // Add click listener to the entire row to update URL when clicking background areas
      row.addEventListener('click', (e) => {
        // Update URL when clicking on background areas (not on interactive elements)
        // This includes clicking on the image container background, form container background, etc.
        if (!isInteractiveElement(e.target)) {
          updatePaintingURL(imageBaseName);
        }
      });
    }
    
    async function saveMetaAuto(image, row, indicator) {
      const body = new FormData();
      body.set('image', image);
      body.set('title', row.querySelector('input[name="title"]').value);
      body.set('description', row.querySelector('textarea[name="description"]').value);
      body.set('width', row.querySelector('input[name="width"]').value);
      body.set('height', row.querySelector('input[name="height"]').value);
      body.set('tags', row.querySelector('input[name="tags"]').value);
      body.set('date', row.querySelector('input[name="date"]').value);
      const soldCheckbox = row.querySelector('input[name="sold"]');
      body.set('sold', soldCheckbox && soldCheckbox.checked ? '1' : '0');
      const frameTypeSelect = row.querySelector('select[name="frame_type"]');
      body.set('frame_type', frameTypeSelect ? frameTypeSelect.value : 'white');
      
      const res = await fetch('save_meta.php', { method: 'POST', body });
      if (!res.ok) {
        if (indicator) {
          indicator.textContent = 'Fehler beim Speichern';
          indicator.style.color = '#dc3545';
          indicator.style.opacity = '1';
        }
        return;
      }
      
      const data = await res.json().catch(() => ({}));
      if (indicator) {
        if (data.in_gallery) {
          indicator.textContent = 'Gespeichert und Live-Version aktualisiert';
        } else {
          indicator.textContent = 'Gespeichert';
        }
        indicator.style.color = '#28a745';
        indicator.style.opacity = '1';
        
        // Fade out after 2 seconds
        setTimeout(() => {
          if (indicator) indicator.style.opacity = '0';
        }, 2000);
      }
    }

    function renderImageRow(g) {
      const row = document.createElement('div');
      row.className = g.in_gallery ? 'rowItem live' : 'rowItem';
      row.id = `painting-${g.base}`;
      const meta = g.meta || {};
      const originalVariant = (g.variants.find(v => v.variant === 'original') || g.variants[0]);
      
      // Find final image
      const finalVariant = g.variants.find(v => v.variant === 'final');
      // Find variant images (those that start with "variant_")
      const imageVariants = g.variants.filter(v => v.variant && v.variant.startsWith('variant_'));
      // Extract variant names that are already added (remove "variant_" prefix)
      const addedVariantNames = new Set(
        imageVariants.map(v => {
          // Extract variant name: "variant_arbeitszimmer" -> "arbeitszimmer"
          return v.variant.replace(/^variant_/, '');
        })
      );
      // Filter available variants to exclude already added ones
      const selectableVariants = availableVariants.filter(v => {
        // Extract variant name from filename: "arbeitszimmer.jpg" -> "arbeitszimmer"
        const variantName = v.name.replace(/\.(jpg|jpeg)$/i, '');
        return !addedVariantNames.has(variantName);
      });
      // Combine: final first, then variants
      const allVariants = [];
      if (finalVariant) {
        allVariants.push(finalVariant);
      }
      allVariants.push(...imageVariants);
      
      // Add cache-busting timestamp to image URLs to ensure fresh load
      const cacheBuster = '?t=' + Date.now();
      const imageClickable = g.in_gallery && g.gallery_filename;
      // Create click handler that includes variant index (1-based: final=1, first variant=2, etc.)
      const imageClickHandler = imageClickable ? `onclick="handleImageClick('${escapeHtml(g.base)}', '${encodeURIComponent(g.gallery_filename)}')"` : '';
      const imageClass = imageClickable ? 'main-image clickable' : 'main-image';
      const badgeClickHandler = `handleBadgeClick('${escapeHtml(originalVariant.name)}', ${g.in_gallery ? 'true' : 'false'})`;
      const showSegmentedButton = finalVariant ? 'show-segmented-button' : '';
      const frameType = meta.frame_type || 'white';
      row.innerHTML = `
        <div class="image-container">
          <div class="main-image-wrapper ${showSegmentedButton}">
            ${g.in_gallery ? `<div class="live-badge clickable" onclick="event.stopPropagation(); event.preventDefault(); ${badgeClickHandler}" title="Zurück auf Entwurf">Live</div>` : `<div class="draft-badge clickable" onclick="event.stopPropagation(); event.preventDefault(); ${badgeClickHandler}" title="Live schalten">Entwurf</div>`}
            <div class="admin-frame-preview frame-${frameType}" id="frame-preview-${g.base}">
              ${finalVariant ? `
                <img class="${imageClass}" id="main-img-${g.base}" loading="lazy" src="${finalVariant.url}${cacheBuster}" alt="${finalVariant.name}" ${imageClickHandler} data-variant="final">
              ` : '<div class="main-image" style="aspect-ratio: 1/1; display: flex; align-items: center; justify-content: center; color: #999;">Kein Final-Bild</div>'}
            </div>
            ${finalVariant ? `
            <div class="segmented-button">
              <div class="segmented-button-section" onclick='doAction("${escapeHtml(originalVariant.name)}", "restore", this)'>Originalbild verwenden</div>
              <div class="segmented-button-section ai-style" onclick='doCorners("${escapeHtml(originalVariant.name)}", this)'><span class="star-icon">⭐</span>KI Bild freistellen lassen</div>
              <div class="segmented-button-section" onclick='doManualFree("${escapeHtml(originalVariant.name)}", this)'>Bild von Hand freistellen</div>
            </div>
            ` : ''}
          </div>
          ${allVariants.length > 0 ? `
            <div class="variant-thumbs" id="thumbs-${g.base}">
              ${allVariants.map((v) => `
                <div class="variant-thumb-wrapper">
                  <img class="variant-thumb ${v.variant === 'final' ? 'active' : ''}" 
                       loading="lazy" 
                       src="${v.url}${cacheBuster}" 
                       alt="${v.name}"
                       data-variant="${v.variant || ''}"
                       onclick="selectVariantByValue('${escapeHtml(g.base)}', '${v.variant || ''}', '${v.url}')"
                       title="${v.name}">
                  ${v.variant && v.variant.startsWith('variant_') ? `
                    <button class="variant-thumb-delete" 
                            onclick="event.stopPropagation(); deleteImageVariant('${escapeHtml(v.name)}', '${escapeHtml(g.base)}', this)"
                            title="Löschen">×</button>
                  ` : ''}
                </div>
              `).join('')}
              <div class="add-variant-btn" onclick="toggleVariants('${escapeHtml(g.base)}')" title="KI Variante hinzufügen">+</div>
            </div>
          ` : `
            <div class="variant-thumbs" id="thumbs-${g.base}">
              <div class="add-variant-btn" onclick="toggleVariants('${escapeHtml(g.base)}')" title="KI Variante hinzufügen">+</div>
            </div>
          `}
          <div class="selectable-variants" id="selectable-variants-${g.base}">
            <div class="selectable-variants-title"><span class="star-icon">⭐</span>KI Varianten</div>
            <div class="selectable-variants-grid" id="variants-${g.base}">
              ${selectableVariants.length > 0 ? selectableVariants.map(v => `
                <img class="selectable-variant-thumb" 
                     src="${escapeHtml(v.url)}" 
                     alt="${escapeHtml(v.name)}"
                     title="${escapeHtml(v.name)}"
                     onclick="copyVariantToImage('${escapeHtml(v.name)}', '${escapeHtml(g.base)}', ${g.in_gallery ? 'true' : 'false'}, '${escapeHtml(originalVariant.name)}', this)">
              `).join('') : '<span class="muted" style="font-size: 11px;">Keine Varianten verfügbar</span>'}
            </div>
          </div>
        </div>
        <div class="form-container" style="padding-right: 8px; position: relative;">
          <button class="delete-icon" style="position: absolute; top: 0; right: 0;" onclick="event.stopPropagation(); deleteCompletely('${escapeHtml(originalVariant.name)}', this)" title="Vollständig löschen">×</button>
          <button type="button" class="ai-fill-button" onclick='fillFormWithAI("${escapeHtml(originalVariant.name)}", this)' title="KI Formular ausfüllen lassen">
            <span class="star-icon">⭐</span>
            <span class="short-text">KI</span>
            <span class="full-text">Formular ausfüllen lassen</span>
          </button>
          <div class="field">
            <label>Titel</label>
            <input type="text" name="title" value="${escapeHtml(meta.title || '')}">
          </div>
          <div class="field">
            <label>Beschreibung</label>
            <textarea name="description" rows="3">${escapeHtml(meta.description || '')}</textarea>
          </div>
          <div style="display: grid; grid-template-columns: auto auto auto; gap: 8px; align-items: end;">
            <div class="field" style="max-width: 100px;">
              <label>Breite (cm)</label>
              <input type="text" name="width" value="${escapeHtml(meta.width || '')}">
            </div>
            <div class="field" style="max-width: 100px;">
              <label>Höhe (cm)</label>
              <input type="text" name="height" value="${escapeHtml(meta.height || '')}">
            </div>
            <div class="field" style="max-width: 120px;">
              <label>Datum (dd.mm.yyyy)</label>
              <input type="text" name="date" value="${escapeHtml(meta.date || '')}">
            </div>
          </div>
          <div class="field">
            <label>Tags</label>
            <input type="text" name="tags" value="${escapeHtml(meta.tags || '')}">
          </div>
          <div class="field">
            <label style="display: flex; align-items: center; gap: 8px;">
              <input type="checkbox" name="sold" ${meta.sold ? 'checked' : ''} style="width: auto; margin: 0;">
              Verkauft
            </label>
          </div>
          <div class="field">
            <label>Rahmen</label>
            <select name="frame_type" id="frame-type-${g.base}" onchange="updateFramePreview('${g.base}', this.value)" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 6px; background: #fff;">
              <option value="white" ${frameType === 'white' ? 'selected' : ''}>Weiß</option>
              <option value="black" ${frameType === 'black' ? 'selected' : ''}>Schwarz</option>
              <option value="wood" ${frameType === 'wood' ? 'selected' : ''}>Holz (Mittel)</option>
              <option value="oak" ${frameType === 'oak' ? 'selected' : ''}>Eiche (Hell)</option>
              <option value="walnut" ${frameType === 'walnut' ? 'selected' : ''}>Walnuss (Dunkel)</option>
              <option value="gold" ${frameType === 'gold' ? 'selected' : ''}>Gold (Einfach)</option>
              <option value="ornate-gold" ${frameType === 'ornate-gold' ? 'selected' : ''}>Gold (Ornamental)</option>
              <option value="silver" ${frameType === 'silver' ? 'selected' : ''}>Silber</option>
              <option value="natural" ${frameType === 'natural' ? 'selected' : ''}>Natur (Beige)</option>
              <option value="none" ${frameType === 'none' ? 'selected' : ''}>Kein Rahmen</option>
            </select>
          </div>
          ${meta.manual_corners && Array.isArray(meta.manual_corners) && meta.manual_corners.length === 4 ? `
          <div class="field" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee;">
            <label style="font-size: 11px; color: #666; margin-bottom: 4px;">Manuelle Ecken-Positionen:</label>
            <div style="font-size: 11px; color: #888; font-family: monospace;">
              Oben links: (${meta.manual_corners[0][0]}, ${meta.manual_corners[0][1]})<br>
              Oben rechts: (${meta.manual_corners[1][0]}, ${meta.manual_corners[1][1]})<br>
              Unten rechts: (${meta.manual_corners[2][0]}, ${meta.manual_corners[2][1]})<br>
              Unten links: (${meta.manual_corners[3][0]}, ${meta.manual_corners[3][1]})
            </div>
          </div>
          ` : ''}
          <div class="auto-save-indicator" id="save-indicator-${g.base}" style="font-size: 11px; color: #666; margin-top: 8px; opacity: 0; transition: opacity 0.3s ease;"></div>
        </div>
      `;
      
      // Store allVariants array on the row for later access (including URLs)
      row.dataset.variants = JSON.stringify(allVariants.map(v => ({ 
        variant: v.variant || '', 
        name: v.name,
        url: v.url
      })));
      
      // Store painting identifier for URL updates
      row.dataset.paintingBase = g.base;
      row.dataset.paintingGalleryFilename = g.gallery_filename || '';
      row.dataset.paintingInGallery = g.in_gallery ? 'true' : 'false';
      
      // Set up auto-save for this row after it's added to DOM
      setTimeout(() => {
        setupAutoSave(g.base, originalVariant.name);
      }, 0);
      
      return row;
    }

    function getVariantIndex(imageBaseName, variantValue) {
      const row = document.getElementById(`painting-${imageBaseName}`);
      if (!row || !row.dataset.variants) return 1; // Default to 1 (final)
      
      try {
        const variants = JSON.parse(row.dataset.variants);
        // Find index of variant (1-based: final=1, first variant=2, etc.)
        const index = variants.findIndex(v => v.variant === variantValue);
        return index >= 0 ? index + 1 : 1; // Return 1-based index, default to 1 if not found
      } catch (e) {
        return 1;
      }
    }

    function updatePaintingURL(imageBaseName) {
      const row = document.getElementById(`painting-${imageBaseName}`);
      if (!row) return;
      
      // Get painting identifier (prefer gallery_filename, fallback to base)
      const galleryFilename = row.dataset.paintingGalleryFilename;
      const base = row.dataset.paintingBase || imageBaseName;
      const paintingId = galleryFilename || base;
      
      // Get current variant
      const mainImg = document.getElementById(`main-img-${imageBaseName}`);
      if (!mainImg) return;
      
      const currentVariant = mainImg.getAttribute('data-variant') || 'final';
      const variantIndex = getVariantIndex(imageBaseName, currentVariant);
      
      // Update URL without reloading
      const newUrl = new URL(window.location);
      newUrl.searchParams.set('painting', paintingId);
      newUrl.searchParams.set('variant', variantIndex.toString());
      
      // Use replaceState to avoid adding to history
      window.history.replaceState({}, '', newUrl);
    }

    function handleImageClick(imageBaseName, galleryFilename) {
      const mainImg = document.getElementById(`main-img-${imageBaseName}`);
      if (!mainImg) return;
      
      const currentVariant = mainImg.getAttribute('data-variant') || 'final';
      const variantIndex = getVariantIndex(imageBaseName, currentVariant);
      
      // Navigate with variant parameter (1-based index)
      const url = `/index.html?painting=${encodeURIComponent(galleryFilename)}&variant=${variantIndex}`;
      window.location.href = url;
    }

    function updateFramePreview(imageBaseName, frameType) {
      const framePreview = document.getElementById(`frame-preview-${imageBaseName}`);
      if (!framePreview) return;
      
      // Remove all frame classes
      framePreview.classList.remove('frame-white', 'frame-wood', 'frame-black', 'frame-gold', 'frame-silver', 'frame-walnut', 'frame-oak', 'frame-ornate-gold', 'frame-natural', 'frame-none');
      // Add the new frame class
      framePreview.classList.add(`frame-${frameType}`);
    }

    function selectVariantByValue(imageBaseName, variantValue, variantUrl) {
      const mainImg = document.getElementById(`main-img-${imageBaseName}`);
      const thumbs = document.getElementById(`thumbs-${imageBaseName}`);
      const wrapper = mainImg ? mainImg.closest('.main-image-wrapper') : null;
      
      if (!mainImg || !thumbs) return;
      
      // Update main image
      mainImg.src = variantUrl.split('?')[0] + '?t=' + Date.now();
      mainImg.setAttribute('data-variant', variantValue || '');
      
      // Update active state on thumbs
      const thumbElements = thumbs.querySelectorAll('.variant-thumb');
      thumbElements.forEach(thumb => {
        if (thumb.getAttribute('data-variant') === variantValue) {
          thumb.classList.add('active');
        } else {
          thumb.classList.remove('active');
        }
      });
      
      // Update segmented button visibility
      if (wrapper) {
        if (variantValue === 'final') {
          wrapper.classList.add('show-segmented-button');
        } else {
          wrapper.classList.remove('show-segmented-button');
        }
      }
      
      // Update URL
      updatePaintingURL(imageBaseName);
    }

    function selectVariant(imageBaseName, variantIndex) {
      const row = document.getElementById(`painting-${imageBaseName}`);
      if (!row || !row.dataset.variants) return;
      
      try {
        const variants = JSON.parse(row.dataset.variants);
        // variantIndex is 1-based, convert to 0-based
        const index = variantIndex - 1;
        if (index < 0 || index >= variants.length) return;
        
        const variant = variants[index];
        const mainImg = document.getElementById(`main-img-${imageBaseName}`);
        const thumbs = document.getElementById(`thumbs-${imageBaseName}`);
        const wrapper = mainImg ? mainImg.closest('.main-image-wrapper') : null;
        
        if (!mainImg || !thumbs || !variant) return;
        
        // Update main image with the variant URL
        const variantUrl = variant.url.split('?')[0] + '?t=' + Date.now();
        mainImg.src = variantUrl;
        mainImg.setAttribute('data-variant', variant.variant || '');
        
        // Update active state on thumbs
        const thumbElements = thumbs.querySelectorAll('.variant-thumb');
        thumbElements.forEach((thumb, idx) => {
          if (idx === index) {
            thumb.classList.add('active');
          } else {
            thumb.classList.remove('active');
          }
        });
        
        // Update segmented button visibility
        if (wrapper) {
          if (variant.variant === 'final') {
            wrapper.classList.add('show-segmented-button');
          } else {
            wrapper.classList.remove('show-segmented-button');
          }
        }
        
        // Update URL
        updatePaintingURL(imageBaseName);
      } catch (e) {
        console.error('Error selecting variant:', e);
      }
    }

    function renderImages(groups) {
      const container = document.getElementById('images');
      container.innerHTML = '';
      if (!groups.length) {
        container.innerHTML = '<p class="muted">Noch keine Bilder vorhanden.</p>';
        return;
      }

      for (const g of groups) {
        const row = renderImageRow(g);
        container.appendChild(row);
      }
    }

    async function refresh() {
      // Fetch variants first
      availableVariants = await fetchVariants();
      
      const { groups } = await fetchImages();
      renderImages(groups);
      
      // Check for painting parameter in URL and scroll to it
      const urlParams = new URLSearchParams(window.location.search);
      const paintingParam = urlParams.get('painting');
      const variantParam = urlParams.get('variant');
      if (paintingParam) {
        // Try to find by gallery_filename first, then fallback to base
        let targetElement = null;
        let targetBase = null;
        for (const g of groups) {
          if (g.gallery_filename && g.gallery_filename.toLowerCase() === paintingParam.toLowerCase()) {
            targetElement = document.getElementById(`painting-${g.base}`);
            targetBase = g.base;
            break;
          }
          if (g.base.toLowerCase() === paintingParam.toLowerCase()) {
            targetElement = document.getElementById(`painting-${g.base}`);
            targetBase = g.base;
            break;
          }
        }
        if (targetElement) {
          setTimeout(() => {
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
            // Highlight the element briefly
            targetElement.style.transition = 'box-shadow 0.3s ease';
            targetElement.style.boxShadow = '0 0 0 4px rgba(11, 95, 255, 0.5)';
            setTimeout(() => {
              targetElement.style.boxShadow = '';
            }, 2000);
            
            // Select variant if parameter is present
            if (variantParam && targetBase) {
              const variantIndex = parseInt(variantParam, 10);
              if (!isNaN(variantIndex) && variantIndex > 0) {
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                  selectVariant(targetBase, variantIndex);
                }, 200);
              }
            }
          }, 100);
        }
      }
    }

    async function deleteImageVariant(filename, imageBaseName, btn) {
      if (!confirm('Möchten Sie diese Variante wirklich löschen?')) {
        return;
      }

      const prev = btn.textContent;
      btn.disabled = true;
      btn.style.opacity = '0.5';

      try {
        const body = new FormData();
        body.set('filename', filename);

        const res = await fetch('delete_image_variant.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Löschen fehlgeschlagen: ' + msg, 'error');
          return;
        }

        const data = await res.json();
        if (!data.ok) {
          showToast('Löschen fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }

        showToast('Variante erfolgreich gelöscht', 'success');
        refresh();
      } catch (error) {
        showToast('Fehler: ' + error.message, 'error');
      } finally {
        btn.disabled = false;
        btn.style.opacity = '';
      }
    }

    async function copyVariantToImage(variantFilename, imageBaseName, isLive, originalImageName, thumbElement) {
      // Update URL when interacting with variant generation
      updatePaintingURL(imageBaseName);
      
      const prevOpacity = thumbElement.style.opacity;
      thumbElement.style.opacity = '0.5';
      thumbElement.style.cursor = 'wait';
      showToast('KI generiert Variante...', 'info', 300000); // 5 minutes max

      try {
        // Get width and height from the form fields
        const row = document.getElementById(`painting-${imageBaseName}`);
        const width = row ? (row.querySelector('input[name="width"]')?.value || '').trim() : '';
        const height = row ? (row.querySelector('input[name="height"]')?.value || '').trim() : '';
        
        const body = new FormData();
        body.set('action', 'copy_to_image');
        body.set('variant_filename', variantFilename);
        body.set('image_base_name', imageBaseName);
        if (width) body.set('width', width);
        if (height) body.set('height', height);

        const res = await fetch('variants.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Fehler beim Generieren: ' + msg, 'error');
          return;
        }

        const data = await res.json();
        if (!data.ok) {
          showToast('Fehler beim Generieren: ' + (data.error || 'Unknown'), 'error');
          return;
        }

        // If image is live, copy to gallery
        if (isLive) {
          showToast('Variante generiert. Aktualisiere Live-Version...', 'info');
          try {
            const copyBody = new FormData();
            copyBody.set('image', originalImageName);
            const copyRes = await fetch('copy_to_gallery.php', { method: 'POST', body: copyBody });
            if (!copyRes.ok) {
              const copyMsg = await copyRes.text();
              showToast('Variante generiert, aber Live-Aktualisierung fehlgeschlagen: ' + copyMsg, 'error');
              // Still update the UI even if copy failed
              await updateImageRow(imageBaseName);
              return;
            }
            const copyData = await copyRes.json().catch(() => ({}));
            if (!copyData.ok) {
              showToast('Variante generiert, aber Live-Aktualisierung fehlgeschlagen: ' + (copyData.error || 'Unknown'), 'error');
              // Still update the UI even if copy failed
              await updateImageRow(imageBaseName);
              return;
            }
            showToast('Variante erfolgreich generiert und Live-Version aktualisiert', 'success');
          } catch (copyError) {
            showToast('Variante generiert, aber Live-Aktualisierung fehlgeschlagen: ' + copyError.message, 'error');
            // Still update the UI even if copy failed
            await updateImageRow(imageBaseName);
            return;
          }
        } else {
          showToast('Variante erfolgreich generiert', 'success');
        }

        // Update only the affected image row instead of full page reload
        await updateImageRow(imageBaseName);
      } catch (error) {
        showToast('Fehler: ' + error.message, 'error');
      } finally {
        thumbElement.style.opacity = prevOpacity || '';
        thumbElement.style.cursor = '';
      }
    }

    async function updateImageRow(imageBaseName) {
      // Fetch updated image data
      const { groups } = await fetchImages();
      const updatedGroup = groups.find(g => g.base === imageBaseName);
      
      if (!updatedGroup) {
        // If image not found, do full refresh as fallback
        refresh();
        return;
      }

      // Find the existing row element
      const existingRow = document.getElementById(`painting-${imageBaseName}`);
      if (!existingRow) {
        // If row not found, do full refresh as fallback
        refresh();
        return;
      }

      // Fetch variants first to ensure they're available
      availableVariants = await fetchVariants();

      // Render the new row
      const newRow = renderImageRow(updatedGroup);
      
      // Replace the old row with the new one
      existingRow.replaceWith(newRow);
      
      // Set up auto-save for the new row
      if (updatedGroup) {
        const originalVariant = (updatedGroup.variants.find(v => v.variant === 'original') || updatedGroup.variants[0]);
        setupAutoSave(imageBaseName, originalVariant.name);
      }
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;'}[c]));
    }

    function toggleVariants(imageBaseName) {
      const variantsSection = document.getElementById(`selectable-variants-${imageBaseName}`);
      if (variantsSection) {
        variantsSection.classList.toggle('visible');
        // Update URL when interacting with variants
        updatePaintingURL(imageBaseName);
      }
    }

    async function handleBadgeClick(imageOriginalName, isLive) {
      // Extract imageBaseName and update URL
      const base = imageOriginalName.replace(/_variant_[^_]+\.(jpg|jpeg|png)$/i, '').replace(/_(original|color|final)\.(jpg|jpeg|png)$/i, '').replace(/\.(jpg|jpeg|png)$/i, '');
      updatePaintingURL(base);
      
      if (isLive) {
        await removeFromGallery(imageOriginalName, {});
      } else {
        await copyToGallery(imageOriginalName, {});
      }
    }

    function showToast(message, type = 'info', duration = 3000) {
      const container = document.getElementById('toastContainer');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      container.appendChild(toast);
      
      // Limit duration to maximum 20 seconds
      const maxDuration = 20000;
      const actualDuration = Math.min(duration, maxDuration);
      
      setTimeout(() => {
        toast.classList.add('hiding');
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 300);
      }, actualDuration);
    }

    // Image resizing function
    async function resizeImage(file, maxWidth = 2048) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            // Check if resizing is needed
            if (img.width <= maxWidth) {
              resolve(file);
              return;
            }
            
            // Calculate new dimensions
            const ratio = maxWidth / img.width;
            const newWidth = maxWidth;
            const newHeight = Math.round(img.height * ratio);
            
            // Create canvas and resize
            const canvas = document.createElement('canvas');
            canvas.width = newWidth;
            canvas.height = newHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, newWidth, newHeight);
            
            // Convert to blob
            canvas.toBlob((blob) => {
              if (!blob) {
                reject(new Error('Failed to resize image'));
                return;
              }
              // Create a new File object with the same name
              const resizedFile = new File([blob], file.name, {
                type: file.type,
                lastModified: Date.now()
              });
              resolve(resizedFile);
            }, file.type, 0.92); // Use 0.92 quality for JPEG
          };
          img.onerror = () => reject(new Error('Failed to load image'));
          img.src = e.target.result;
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsDataURL(file);
      });
    }

    // Format time duration
    function formatDuration(seconds) {
      if (seconds < 60) {
        return `${Math.round(seconds)}s`;
      }
      const mins = Math.floor(seconds / 60);
      const secs = Math.round(seconds % 60);
      return `${mins}m ${secs}s`;
    }

    window.addEventListener('DOMContentLoaded', () => {
      showFlashFromQuery();
      refresh();
      
      const fileInput = document.getElementById('fileInput');
      const uploadArea = document.getElementById('uploadArea');
      const uploadForm = document.getElementById('uploadForm');
      
      const aiFileInput = document.getElementById('aiFileInput');
      const aiUploadArea = document.getElementById('aiUploadArea');
      const aiUploadForm = document.getElementById('aiUploadForm');
      
      // Regular upload area click handler
      uploadArea.addEventListener('click', () => {
        fileInput.click();
      });
      
      // AI upload area click handler
      aiUploadArea.addEventListener('click', () => {
        aiFileInput.click();
      });
      
      // Regular file input change handler
      fileInput.addEventListener('change', async (e) => {
        if (!fileInput.files || fileInput.files.length === 0) return;
        await uploadFiles(fileInput.files, false);
      }, { passive: true });
      
      // AI file input change handler
      aiFileInput.addEventListener('change', async (e) => {
        if (!aiFileInput.files || aiFileInput.files.length === 0) return;
        await uploadFiles(aiFileInput.files, true);
      }, { passive: true });
      
      // Regular drag and drop handlers
      uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.add('dragover');
      });
      
      uploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.remove('dragover');
      });
      
      uploadArea.addEventListener('drop', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.remove('dragover');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          await uploadFiles(files, false);
        }
      });
      
      // AI drag and drop handlers
      aiUploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        aiUploadArea.classList.add('dragover');
      });
      
      aiUploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        aiUploadArea.classList.remove('dragover');
      });
      
      aiUploadArea.addEventListener('drop', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        aiUploadArea.classList.remove('dragover');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          await uploadFiles(files, true);
        }
      });
      
      async function uploadFiles(files, isAIUpload) {
        const startTime = Date.now();
        const progressContainer = isAIUpload ? document.getElementById('aiUploadProgress') : document.getElementById('regularUploadProgress');
        const progressBar = isAIUpload ? document.getElementById('aiUploadProgressBar') : document.getElementById('regularUploadProgressBar');
        const statusText = isAIUpload ? document.getElementById('aiUploadStatus') : document.getElementById('regularUploadStatus');
        const timeText = isAIUpload ? document.getElementById('aiUploadTime') : document.getElementById('regularUploadTime');
        const fileInputElement = isAIUpload ? aiFileInput : fileInput;
        
        // Show progress container
        progressContainer.style.display = 'block';
        progressBar.style.width = '0%';
        statusText.textContent = isAIUpload ? 'Bilder werden vorbereitet...' : 'Bilder werden vorbereitet...';
        
        try {
          // Resize images if needed
          const resizedFiles = [];
          for (let i = 0; i < files.length; i++) {
            statusText.textContent = isAIUpload 
              ? `Bild ${i + 1}/${files.length} wird vorbereitet...`
              : `Bild ${i + 1}/${files.length} wird vorbereitet...`;
            try {
              const resized = await resizeImage(files[i]);
              resizedFiles.push(resized);
            } catch (error) {
              console.error('Error resizing image:', error);
              // Use original file if resize fails
              resizedFiles.push(files[i]);
            }
          }
          
          // Create FormData
          const fd = new FormData();
          for (let i = 0; i < resizedFiles.length; i++) {
            fd.append('images[]', resizedFiles[i]);
          }
          
          // Add AI upload flag
          if (isAIUpload) {
            fd.append('ai_upload', '1');
          }
          
          // Upload with progress tracking
          statusText.textContent = isAIUpload ? 'Bilder werden hochgeladen...' : 'Bilder werden hochgeladen...';
          progressBar.style.width = '30%';
          
          const xhr = new XMLHttpRequest();
          
          // Track upload progress
          xhr.upload.addEventListener('progress', (e) => {
            if (e.lengthComputable) {
              const percentComplete = 30 + (e.loaded / e.total) * 70; // 30% for prep, 70% for upload
              progressBar.style.width = percentComplete + '%';
            }
          });
          
          // Update time display
          const timeInterval = setInterval(() => {
            const elapsed = (Date.now() - startTime) / 1000;
            timeText.textContent = `Dauer: ${formatDuration(elapsed)}`;
          }, 100);
          
          const uploadPromise = new Promise((resolve, reject) => {
            xhr.onload = () => {
              clearInterval(timeInterval);
              if (xhr.status >= 200 && xhr.status < 300) {
                progressBar.style.width = '100%';
                // Check if response is JSON (AI upload) or redirect (regular upload)
                const contentType = xhr.getResponseHeader('Content-Type') || '';
                if (contentType.includes('application/json')) {
                  try {
                    const data = JSON.parse(xhr.responseText);
                    resolve(data);
                  } catch (e) {
                    resolve({ ok: true, responseText: xhr.responseText });
                  }
                } else {
                  // Regular upload - redirect response
                  resolve({ ok: true, redirect: true });
                }
              } else {
                reject(new Error(`Upload failed: ${xhr.status}`));
              }
            };
            xhr.onerror = () => {
              clearInterval(timeInterval);
              reject(new Error('Upload failed'));
            };
            xhr.open('POST', 'upload.php');
            xhr.send(fd);
          });
          
          const response = await uploadPromise;
          const elapsed = (Date.now() - startTime) / 1000;
          timeText.textContent = `Abgeschlossen in ${formatDuration(elapsed)}`;
          
          if (isAIUpload) {
            // Parse response to get uploaded image names
            if (response.ok && response.uploaded_images && response.uploaded_images.length > 0) {
              // Process each uploaded image with AI
              await processAIImageWorkflow(response.uploaded_images, startTime);
            } else {
              showToast('Upload erfolgreich, aber AI-Verarbeitung konnte nicht gestartet werden', 'error');
              refresh();
            }
          } else {
            showToast(`${files.length} Bild(er) erfolgreich hochgeladen`, 'success');
            fileInputElement.value = '';
            setTimeout(() => {
              progressContainer.style.display = 'none';
            }, 2000);
            refresh();
          }
        } catch (error) {
          showToast('Fehler beim Hochladen: ' + error.message, 'error');
          progressContainer.style.display = 'none';
        }
      }
      
      async function processAIImageWorkflow(uploadedImages, startTime) {
        const step1 = document.getElementById('aiStep1');
        const step2 = document.getElementById('aiStep2');
        const step3 = document.getElementById('aiStep3');
        const step4 = document.getElementById('aiStep4');
        const progressBar = document.getElementById('aiUploadProgressBar');
        const statusText = document.getElementById('aiUploadStatus');
        const timeText = document.getElementById('aiUploadTime');
        
        // Update time display continuously
        const timeInterval = setInterval(() => {
          const elapsed = (Date.now() - startTime) / 1000;
          timeText.textContent = `Dauer: ${formatDuration(elapsed)}`;
        }, 100);
        
        // Process each image sequentially
        for (let i = 0; i < uploadedImages.length; i++) {
          const imageName = uploadedImages[i];
          const imageBase = imageName.replace(/_original\.(jpg|jpeg|png)$/i, '');
          
          // Calculate progress: upload is 25%, each image processing is 75% / (images * steps)
          const baseProgress = 25;
          const progressPerImage = 75 / uploadedImages.length;
          const progressPerStep = progressPerImage / 4; // 4 steps per image
          
          try {
            // Step 1: Upload complete
            step1.textContent = `✅ Upload abgeschlossen (${i + 1}/${uploadedImages.length})`;
            step1.style.opacity = '1';
            step2.style.opacity = '0.5';
            step3.style.opacity = '0.5';
            step4.style.opacity = '0.5';
            const imageProgress = baseProgress + (i * progressPerImage);
            progressBar.style.width = imageProgress + '%';
            statusText.textContent = `Bild ${i + 1}/${uploadedImages.length}: KI Bild freistellen lassen...`;
            
            // Step 2: KI Bild freistellen lassen
            step2.textContent = `🔄 KI Bild freistellen lassen (${i + 1}/${uploadedImages.length})...`;
            step2.style.opacity = '1';
            progressBar.style.width = (imageProgress + progressPerStep) + '%';
            
            const cornersRes = await fetch('corners.php', {
              method: 'POST',
              body: (() => {
                const fd = new FormData();
                fd.append('image_path', 'admin/images/' + imageName);
                fd.append('color', '#ffffff');
                return fd;
              })()
            });
            
            if (!cornersRes.ok) {
              throw new Error('KI Bild freistellen fehlgeschlagen');
            }
            
            const cornersData = await cornersRes.json();
            if (!cornersData.ok) {
              throw new Error('KI Bild freistellen fehlgeschlagen: ' + (cornersData.error || 'Unknown'));
            }
            
            step2.textContent = `✅ KI Bild freistellen abgeschlossen (${i + 1}/${uploadedImages.length})`;
            progressBar.style.width = (imageProgress + progressPerStep * 2) + '%';
            
            // Step 3: KI Formular ausfüllen lassen
            step3.textContent = `🔄 KI Formular ausfüllen lassen (${i + 1}/${uploadedImages.length})...`;
            step3.style.opacity = '1';
            statusText.textContent = `Bild ${i + 1}/${uploadedImages.length}: KI Formular ausfüllen lassen...`;
            progressBar.style.width = (imageProgress + progressPerStep * 2.5) + '%';
            
            const fillFormRes = await fetch('ai_fill_form.php', {
              method: 'POST',
              body: (() => {
                const fd = new FormData();
                fd.append('image', imageName);
                return fd;
              })()
            });
            
            if (!fillFormRes.ok) {
              throw new Error('KI Formular ausfüllen fehlgeschlagen');
            }
            
            const fillFormData = await fillFormRes.json();
            if (!fillFormData.ok) {
              throw new Error('KI Formular ausfüllen fehlgeschlagen: ' + (fillFormData.error || 'Unknown'));
            }
            
            // Save the form data
            const saveMetaRes = await fetch('save_meta.php', {
              method: 'POST',
              body: (() => {
                const fd = new FormData();
                fd.append('image', imageName);
                if (fillFormData.title) fd.append('title', fillFormData.title);
                if (fillFormData.description) fd.append('description', fillFormData.description);
                if (fillFormData.width) fd.append('width', fillFormData.width);
                if (fillFormData.height) fd.append('height', fillFormData.height);
                if (fillFormData.tags) fd.append('tags', fillFormData.tags);
                if (fillFormData.date) fd.append('date', fillFormData.date);
                fd.append('sold', '0');
                fd.append('frame_type', 'white');
                return fd;
              })()
            });
            
            if (saveMetaRes.ok) {
              const saveMetaData = await saveMetaRes.json().catch(() => ({}));
              // Form data saved (or will be saved)
            }
            
            step3.textContent = `✅ KI Formular ausfüllen abgeschlossen (${i + 1}/${uploadedImages.length})`;
            progressBar.style.width = (imageProgress + progressPerStep * 3) + '%';
            
            // Step 4: Generate random variant
            step4.textContent = `🔄 KI Variante generieren (${i + 1}/${uploadedImages.length})...`;
            step4.style.opacity = '1';
            statusText.textContent = `Bild ${i + 1}/${uploadedImages.length}: KI Variante generieren...`;
            progressBar.style.width = (imageProgress + progressPerStep * 3.5) + '%';
            
            // Get available variants
            const variantsRes = await fetch('variants.php?action=list');
            if (!variantsRes.ok) {
              throw new Error('Varianten konnten nicht geladen werden');
            }
            
            const variantsData = await variantsRes.json();
            if (!variantsData.ok || !variantsData.variants || variantsData.variants.length === 0) {
              step4.textContent = `⏭ KI Variante übersprungen (keine Varianten verfügbar)`;
              step4.style.opacity = '0.7';
            } else {
              // Pick a random variant
              const randomVariant = variantsData.variants[Math.floor(Math.random() * variantsData.variants.length)];
              
              const variantRes = await fetch('variants.php', {
                method: 'POST',
                body: (() => {
                  const fd = new FormData();
                  fd.append('action', 'copy_to_image');
                  fd.append('variant_filename', randomVariant.name);
                  fd.append('image_base_name', imageBase);
                  if (fillFormData.width) fd.append('width', fillFormData.width);
                  if (fillFormData.height) fd.append('height', fillFormData.height);
                  return fd;
                })()
              });
              
              if (!variantRes.ok) {
                throw new Error('KI Variante generieren fehlgeschlagen');
              }
              
              const variantData = await variantRes.json();
              if (!variantData.ok) {
                throw new Error('KI Variante generieren fehlgeschlagen: ' + (variantData.error || 'Unknown'));
              }
              
              step4.textContent = `✅ KI Variante generiert (${i + 1}/${uploadedImages.length})`;
            }
            
            progressBar.style.width = (imageProgress + progressPerImage) + '%';
            
          } catch (error) {
            console.error('Error processing image:', error);
            showToast(`Fehler bei Bild ${i + 1}: ${error.message}`, 'error');
            // Continue with next image
          }
        }
        
        clearInterval(timeInterval);
        
        // All done
        progressBar.style.width = '100%';
        const elapsed = (Date.now() - startTime) / 1000;
        timeText.textContent = `Abgeschlossen in ${formatDuration(elapsed)}`;
        statusText.textContent = `Alle ${uploadedImages.length} Bild(er) erfolgreich verarbeitet`;
        showToast(`${uploadedImages.length} Bild(er) erfolgreich hochgeladen und verarbeitet`, 'success');
        
        aiFileInput.value = '';
        setTimeout(() => {
          document.getElementById('aiUploadProgress').style.display = 'none';
        }, 5000);
        refresh();
      }
    });
  </script>
  <noscript>Please enable JavaScript to view and select images.</noscript>
  <meta name="robots" content="noindex, nofollow">
  <meta http-equiv="Cache-Control" content="no-store" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <link rel="icon" href="data:,">
  <title>Administration der Herzfabrik</title>
  </head>
<body>
  <div id="toastContainer" class="toast-container"></div>
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; flex-wrap: wrap; gap: 12px;">
    <h1 style="margin: 0;">Administration der <a href="/index.html" id="site-domain-link" style="color: #DC143C; text-decoration: none;">Herzfabrik</a></h1>
    <div style="display: flex; gap: 12px; align-items: center;">
      <a href="index.html" style="color: #555; text-decoration: none; font-size: 14px; padding: 6px 12px; border: 1px solid #888; border-radius: 6px; background: #f5f5f5;">Gemälde</a>
      <a href="variants.html" style="color: #555; text-decoration: none; font-size: 14px; padding: 6px 12px; border: 1px solid #888; border-radius: 6px;">Raum-Mockups</a>
      <a href="artist.html" style="color: #555; text-decoration: none; font-size: 14px; padding: 6px 12px; border: 1px solid #888; border-radius: 6px;">Künstler</a>
    </div>
  </div>
  <div id="flash" class="flash hidden"></div>

  <div class="">
    <h2>Gemälde hochladen</h2>
    <div class="upload-sections" style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin-bottom: 24px;">
      <!-- Regular Upload Section -->
      <div>
        <h3 style="font-size: 14px; margin-bottom: 12px; color: #555;">Standard Upload</h3>
        <form id="uploadForm" action="/admin/upload.php" method="post" enctype="multipart/form-data">
          <div id="uploadArea" class="upload-area">
            <div class="upload-area-text">📷 Bilder hier ablegen oder klicken zum Auswählen</div>
            <div class="upload-area-hint">Sie können mehrere Bilder gleichzeitig hochladen</div>
            <input type="file" name="images[]" accept="image/*" multiple required style="display: none;" id="fileInput">
          </div>
        </form>
        <div id="regularUploadProgress" style="display: none; margin-top: 12px;">
          <div style="font-size: 12px; color: #666; margin-bottom: 4px;">
            <span id="regularUploadStatus">Wird hochgeladen...</span>
            <span id="regularUploadTime" style="margin-left: 8px;"></span>
          </div>
          <div style="width: 100%; height: 8px; background: #e8e8e8; border-radius: 4px; overflow: hidden;">
            <div id="regularUploadProgressBar" style="height: 100%; background: #28a745; width: 0%; transition: width 0.3s ease;"></div>
          </div>
        </div>
      </div>
      
      <!-- AI Upload Section -->
      <div>
        <h3 style="font-size: 14px; margin-bottom: 12px; color: #555;">
          <span class="star-icon">⭐</span> KI Upload (Automatische Verarbeitung)
        </h3>
        <form id="aiUploadForm" action="/admin/upload.php" method="post" enctype="multipart/form-data">
          <div id="aiUploadArea" class="upload-area" style="background: linear-gradient(135deg, #f8f5ff 0%, #f0ebff 100%); border-color: #667eea;">
            <div class="upload-area-text">⭐ KI Bilder hier ablegen oder klicken</div>
            <div class="upload-area-hint">Automatische Verarbeitung: Freistellen → Formular → Variante</div>
            <input type="file" name="images[]" accept="image/*" multiple required style="display: none;" id="aiFileInput">
          </div>
        </form>
        <div id="aiUploadProgress" style="display: none; margin-top: 12px;">
          <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
            <div id="aiUploadStatus">Wird hochgeladen...</div>
            <div id="aiUploadTime" style="margin-top: 4px;"></div>
          </div>
          <div style="width: 100%; height: 8px; background: #e8e8e8; border-radius: 4px; overflow: hidden; margin-bottom: 8px;">
            <div id="aiUploadProgressBar" style="height: 100%; background: #667eea; width: 0%; transition: width 0.3s ease;"></div>
          </div>
          <div id="aiStepsProgress" style="font-size: 11px; color: #888;">
            <div id="aiStep1" style="margin-bottom: 4px;">⏳ Warte auf Upload...</div>
            <div id="aiStep2" style="margin-bottom: 4px; opacity: 0.5;">⏸ KI Bild freistellen lassen</div>
            <div id="aiStep3" style="margin-bottom: 4px; opacity: 0.5;">⏸ KI Formular ausfüllen lassen</div>
            <div id="aiStep4" style="opacity: 0.5;">⏸ KI Variante generieren</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="">
    <div class="toolbar">
      <h2>Gemälde</h2>
    </div>
    <div id="images" class="list"></div>
  </div>

  <script>
    function showFlashFromQuery() {
      const url = new URL(window.location.href);
      const processed = url.searchParams.get('processed');
      const errors = url.searchParams.get('errors');
      const errorsDetailRaw = url.searchParams.get('errors_detail');
      if (!processed && !errors) return;
      const box = document.getElementById('flash');
      box.classList.remove('hidden');
      const p = parseInt(processed || '0', 10);
      const e = parseInt(errors || '0', 10);
      let html = '';
      if (e > 0) {
        box.classList.remove('success');
        html += `<strong>Processing finished:</strong> ${p} succeeded, ${e} failed.`;
        if (errorsDetailRaw) {
          try {
            const details = JSON.parse(errorsDetailRaw);
            if (Array.isArray(details) && details.length) {
              html += '<div style="margin-top:8px"><strong>Errors:</strong><ul>' +
                details.map(d => `<li>${String(d)}</li>`).join('') + '</ul></div>';
            }
          } catch {}
        }
      } else {
        box.classList.add('success');
        html += `<strong>Success:</strong> Processed ${p} image(s).`;
      }
      box.innerHTML = html;
      // Clean params from URL without reloading
      window.history.replaceState({}, '', url.pathname);
    }

    async function saveMeta(image, btn) {
      const item = btn.closest('.rowItem');
      const body = new FormData();
      body.set('image', image);
      body.set('title', item.querySelector('input[name=\"title\"]').value);
      body.set('description', item.querySelector('textarea[name=\"description\"]').value);
      body.set('width', item.querySelector('input[name=\"width\"]').value);
      body.set('height', item.querySelector('input[name=\"height\"]').value);
      body.set('tags', item.querySelector('input[name=\"tags\"]').value);
      body.set('date', item.querySelector('input[name=\"date\"]').value);
      const soldCheckbox = item.querySelector('input[name=\"sold\"]');
      body.set('sold', soldCheckbox && soldCheckbox.checked ? '1' : '0');
      btn.disabled = true;
      const res = await fetch('save_meta.php', { method: 'POST', body });
      btn.disabled = false;
      if (!res.ok) {
        showToast('Fehler beim Speichern der Metadaten', 'error');
        return;
      }
      const data = await res.json().catch(() => ({}));
      if (data.in_gallery) {
        showToast('Metadaten gespeichert und Live-Version aktualisiert', 'success');
        // Refresh to update button state
        refresh();
      } else {
        showToast('Metadaten gespeichert', 'success');
      }
    }

    async function doAction(image, action, btn) {
      // Extract imageBaseName and update URL
      const row = btn.closest ? btn.closest('.rowItem') : null;
      const imageBaseName = row ? row.dataset.paintingBase : null;
      if (imageBaseName) {
        updatePaintingURL(imageBaseName);
      }
      
      if (btn.disabled !== undefined) {
        btn.disabled = true;
      } else {
        btn.classList.add('loading');
      }
      const prevText = btn.textContent;
      if (action === 'restore' && btn.textContent !== undefined) {
        btn.textContent = 'Wird kopiert…';
      }
      
      const body = new FormData();
      body.set('image', image);
      body.set('action', action);
      
      try {
        const res = await fetch('action.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Fehler: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('Fehler: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        
        if (action === 'restore') {
          showToast('Originalbild wird geladen…', 'info');
          
          // Extract base name: remove _original, _color, _final, or _variant_* suffix and extension
          const base = image.replace(/_variant_[^_]+\.(jpg|jpeg|png)$/i, '').replace(/_(original|color|final)\.(jpg|jpeg|png)$/i, '').replace(/\.(jpg|jpeg|png)$/i, '');
          
          // Wait a bit for the file copy operation to complete on the server
          await new Promise(resolve => setTimeout(resolve, 300));
          
          // Update only the affected image row instead of full page reload
          await updateImageRow(base);
          
          // Wait for the DOM to be updated
          await new Promise(resolve => setTimeout(resolve, 50));
          
          // Find the main image and wait for it to load
          const mainImg = document.getElementById(`main-img-${base}`);
          if (mainImg) {
            // Show loading state
            mainImg.style.opacity = '0.5';
            mainImg.style.transition = 'opacity 0.3s ease';
            
            // Get the base URL without query string
            const baseUrl = mainImg.src.split('?')[0];
            const freshUrl = baseUrl + '?t=' + Date.now();
            
            // Preload the image to ensure it's ready before showing it
            await new Promise((resolve) => {
              // Check if image is already complete
              if (mainImg.complete && mainImg.naturalWidth > 0) {
                // Image is already loaded, just update src and show
                mainImg.src = freshUrl;
                mainImg.style.opacity = '1';
                showToast('Originalbild erfolgreich verwendet', 'success');
                resolve();
                return;
              }
              
              // Preload the image
              const img = new Image();
              img.onload = () => {
                // Image is loaded, now update the displayed image
                mainImg.src = freshUrl;
                mainImg.style.opacity = '1';
                showToast('Originalbild erfolgreich verwendet', 'success');
                resolve();
              };
              img.onerror = () => {
                // Retry once after a short delay
                setTimeout(() => {
                  const retryImg = new Image();
                  retryImg.onload = () => {
                    mainImg.src = freshUrl;
                    mainImg.style.opacity = '1';
                    showToast('Originalbild erfolgreich verwendet', 'success');
                    resolve();
                  };
                  retryImg.onerror = () => {
                    mainImg.style.opacity = '1';
                    showToast('Originalbild verwendet, aber Bild konnte nicht geladen werden. Bitte Seite aktualisieren.', 'error');
                    resolve(); // Still resolve to not block
                  };
                  retryImg.src = freshUrl;
                }, 500);
              };
              img.src = freshUrl;
            });
          } else {
            // Fallback: full refresh if image element not found
            await refresh();
            showToast('Originalbild erfolgreich verwendet', 'success');
          }
        } else {
          await refresh();
        }
      } finally {
        if (btn.disabled !== undefined) {
          btn.disabled = false;
        } else {
          btn.classList.remove('loading');
        }
        if (btn.textContent !== undefined) btn.textContent = prevText;
      }
    }

    async function doCorners(imageOriginalName, btn) {
      // Extract imageBaseName and update URL
      const row = btn.closest ? btn.closest('.rowItem') : null;
      const imageBaseName = row ? row.dataset.paintingBase : null;
      if (imageBaseName) {
        updatePaintingURL(imageBaseName);
      }
      
      const prev = btn.textContent;
      if (btn.disabled !== undefined) {
        btn.disabled = true;
      } else {
        btn.classList.add('loading');
      }
      if (btn.textContent !== undefined) btn.textContent = 'KI…';
      try {
        const body = new FormData();
        body.set('image_path', 'admin/images/' + imageOriginalName);
        body.set('color', '#ffffff');
        const res = await fetch('corners.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('KI-Verarbeitung fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('KI-Verarbeitung fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        showToast('KI-Verarbeitung erfolgreich abgeschlossen', 'success');
        // Extract base name: remove _original, _color, _final, or _variant_* suffix and extension
        const base = imageOriginalName.replace(/_variant_[^_]+\.(jpg|jpeg|png)$/i, '').replace(/_(original|color|final)\.(jpg|jpeg|png)$/i, '').replace(/\.(jpg|jpeg|png)$/i, '');
        await refresh();
        // Force reload the main image after refresh with a small delay to ensure DOM is ready
        setTimeout(() => {
          const mainImg = document.getElementById(`main-img-${base}`);
          if (mainImg) {
            // Force reload by adding/updating cache-busting parameter
            const currentSrc = mainImg.src;
            const separator = currentSrc.includes('?') ? '&' : '?';
            mainImg.src = currentSrc.split('?')[0] + separator + 't=' + Date.now();
          }
        }, 100);
      } finally {
        if (btn.disabled !== undefined) {
          btn.disabled = false;
        } else {
          btn.classList.remove('loading');
        }
        if (btn.textContent !== undefined) btn.textContent = prev;
      }
    }

    function doManualFree(imageOriginalName, btn) {
      // Extract base name: remove _original, _color, _final, or _variant_* suffix and extension
      const base = imageOriginalName.replace(/_variant_[^_]+\.(jpg|jpeg|png)$/i, '').replace(/_(original|color|final)\.(jpg|jpeg|png)$/i, '').replace(/\.(jpg|jpeg|png)$/i, '');
      window.location.href = `free.html?painting=${encodeURIComponent(base)}`;
    }

    async function fillFormWithAI(imageOriginalName, btn) {
      const prev = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'KI…';
      try {
        const item = btn.closest('.rowItem');
        const imageBaseName = item ? item.dataset.paintingBase : null;
        if (imageBaseName) {
          updatePaintingURL(imageBaseName);
        }
        
        // Find the final image URL to log
        const mainImg = item.querySelector('.main-image');
        const imageUrl = mainImg ? mainImg.src : 'images/' + imageOriginalName;
        console.log('KI Formular ausfüllen: Verwende Bild:', imageUrl);
        
        const body = new FormData();
        body.set('image', imageOriginalName);
        const res = await fetch('ai_fill_form.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('KI-Formularausfüllung fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('KI-Formularausfüllung fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        
        // Check for warning
        if (data.warning) {
          showToast(data.warning, 'error');
          return;
        }
        
        // Fill form fields with AI-generated data
        let filled = false;
        if (data.title) {
          item.querySelector('input[name="title"]').value = data.title;
          filled = true;
        }
        if (data.description) {
          item.querySelector('textarea[name="description"]').value = data.description;
          filled = true;
        }
        if (data.tags) {
          item.querySelector('input[name="tags"]').value = data.tags;
          filled = true;
        }
        if (data.date) {
          item.querySelector('input[name="date"]').value = data.date;
          filled = true;
        }
        if (data.width) {
          item.querySelector('input[name="width"]').value = data.width;
          filled = true;
        }
        if (data.height) {
          item.querySelector('input[name="height"]').value = data.height;
          filled = true;
        }
        
        if (filled) {
          showToast('Formular erfolgreich von KI ausgefüllt', 'success');
          // Automatically save the form using auto-save
          // Trigger input events to activate auto-save
          const fields = [
            item.querySelector('input[name="title"]'),
            item.querySelector('textarea[name="description"]'),
            item.querySelector('input[name="width"]'),
            item.querySelector('input[name="height"]'),
            item.querySelector('input[name="tags"]'),
            item.querySelector('input[name="date"]')
          ].filter(f => f !== null);
          fields.forEach(field => {
            field.dispatchEvent(new Event('input', { bubbles: true }));
          });
        } else {
          showToast('Keine Daten von KI erhalten', 'error');
        }
      } finally {
        btn.disabled = false;
        btn.textContent = prev;
      }
    }

    async function copyToGallery(imageOriginalName, btn) {
      const prev = btn.textContent;
      if (btn.disabled !== undefined) btn.disabled = true;
      if (btn.textContent !== undefined) btn.textContent = 'Schalte live…';
      try {
        const body = new FormData();
        body.set('image', imageOriginalName);
        const res = await fetch('copy_to_gallery.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Live schalten fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('Live schalten fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        showToast('Erfolgreich live geschaltet', 'success');
        refresh();
      } finally {
        if (btn.disabled !== undefined) btn.disabled = false;
        if (btn.textContent !== undefined) btn.textContent = prev;
      }
    }

    async function removeFromGallery(imageOriginalName, btn) {
      const prev = btn.textContent;
      if (btn.disabled !== undefined) btn.disabled = true;
      if (btn.textContent !== undefined) btn.textContent = 'Entferne live…';
      try {
        const body = new FormData();
        body.set('image', imageOriginalName);
        const res = await fetch('remove_from_gallery.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Live entfernen fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('Live entfernen fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        showToast('Erfolgreich live entfernt', 'success');
        refresh();
      } finally {
        if (btn.disabled !== undefined) btn.disabled = false;
        if (btn.textContent !== undefined) btn.textContent = prev;
      }
    }

    async function deleteCompletely(imageOriginalName, btn) {
      if (!confirm('Möchten Sie wirklich alle Dateien dieses Gemäldes löschen? Dies kann nicht rückgängig gemacht werden.')) {
        return;
      }
      const prev = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Lösche…';
      try {
        const body = new FormData();
        body.set('image', imageOriginalName);
        const res = await fetch('delete_completely.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Löschen fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('Löschen fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        showToast('Alle Dateien erfolgreich gelöscht', 'success');
        refresh();
      } finally {
        btn.disabled = false;
        btn.textContent = prev;
      }
    }
    
    // Update site domain link in header
    async function updateSiteDomainLink() {
      try {
        const res = await fetch('get_artist_content.php');
        if (!res.ok) return;
        const data = await res.json();
        if (data.ok && data.domain) {
          const domainLink = document.getElementById('site-domain-link');
          if (domainLink) {
            // Capitalize first letter
            const domainText = data.domain.charAt(0).toUpperCase() + data.domain.slice(1);
            domainLink.textContent = domainText;
          }
        }
      } catch (error) {
        // Silently fail - keep default "Herzfabrik"
      }
    }
    
    // Update domain link on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', updateSiteDomainLink);
    } else {
      updateSiteDomainLink();
    }
  </script>
</body>
</html>


