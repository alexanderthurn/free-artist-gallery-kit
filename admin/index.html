<!DOCTYPE html>
<html lang="en" style="color-scheme: light only;">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light">
  <title>Administration der Herzfabrik</title>
  <style>
    html { color-scheme: light; background: #fff; }
    body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; background: #fff; color: #000; }
    h1 { font-size: 20px; margin: 0 0 16px; color: #000; }
    h2 { font-size: 16px; margin: 24px 0 12px; color: #000; }
    .upload-area { border: 3px dashed #888; border-radius: 12px; padding: 32px; background: #f5f5f5; text-align: center; transition: all 0.3s ease; cursor: pointer; }
    .upload-area:hover { background: #e8e8e8; border-color: #666; }
    .upload-area.dragover { background: #ddd; border-color: #666; border-style: solid; }
    .upload-area-text { color: #555; font-weight: 500; margin-bottom: 8px; }
    .upload-area-hint { color: #666; font-size: 13px; }
    .list { display: flex; flex-direction: column; gap: 12px; }
    .rowItem { display: grid; grid-template-columns: 300px 1fr; gap: 24px; border: 1px solid #eee; border-radius: 8px; padding: 16px; align-items: start; position: relative; background: #fff; }
    .rowItem.live { border-color: #28a745; background: #f6fffa; }
    .image-container { position: relative; width: 100%; max-width: 300px; }
    .main-image-wrapper { position: relative; width: 100%; max-width: 300px; }
    .live-badge { position: absolute; top: 12px; left: 12px; background: #28a745; color: #fff; padding: 8px 16px; border-radius: 12px; font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; z-index: 100; }
    .live-badge.clickable { cursor: pointer; transition: all 0.2s ease; }
    .live-badge.clickable:hover { background: #218838; transform: scale(1.05); }
    .draft-badge { position: absolute; top: 12px; left: 12px; background: #ffc107; color: #000; padding: 8px 16px; border-radius: 12px; font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; z-index: 100; }
    .draft-badge.clickable { cursor: pointer; transition: all 0.2s ease; }
    .draft-badge.clickable:hover { background: #e0a800; transform: scale(1.05); }
    .main-image { width: 100%; max-width: 300px; border-radius: 0; background: #fafafa; position: relative; }
    .main-image.clickable { cursor: pointer; transition: opacity 0.2s ease; }
    .main-image.clickable:hover { opacity: 0.9; }
    .delete-icon { width: 32px; height: 32px; border-radius: 50%; background: #dc3545; color: #fff; border: 2px solid #dc3545; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; line-height: 1; padding: 0; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3); }
    .delete-icon:hover { background: #c82333; border-color: #c82333; transform: scale(1.1); box-shadow: 0 4px 8px rgba(220, 53, 69, 0.5); }
    .form-container { position: relative;  }
    .ai-fill-button { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; display: inline-flex; align-items: center; gap: 8px; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3); margin-bottom: 16px; white-space: nowrap; overflow: hidden; }
    .ai-fill-button:hover { transform: translateY(-1px); box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4); }
    .ai-fill-button:active { transform: translateY(0); }
    .ai-fill-button .star-icon { font-size: 16px; flex-shrink: 0; }
    .ai-fill-button .short-text { display: inline-block; }
    .ai-fill-button .full-text { display: inline-block; max-width: 0; opacity: 0; overflow: hidden; transition: max-width 0.3s ease, opacity 0.3s ease; }
    .ai-fill-button:hover .short-text { display: none; }
    .ai-fill-button:hover .full-text { max-width: 300px; opacity: 1; }
    @media (hover: none) {
      .ai-fill-button .short-text { display: none; }
      .ai-fill-button .full-text { max-width: 300px; opacity: 1; }
    }
    .main-image-wrapper .segmented-button { display: flex; width: calc(100% - 24px); border: 1px solid #ccc; border-radius: 6px; overflow: hidden; background: #fff; position: absolute; bottom: 12px; left: 12px; right: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.25); z-index: 50; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; }
    .main-image-wrapper.show-segmented-button:hover .segmented-button { opacity: 1; visibility: visible; }
    @media (hover: none) {
      .main-image-wrapper.show-segmented-button .segmented-button { opacity: 1; visibility: visible; }
    }
    .segmented-button-section { flex: 1; padding: 10px 12px; text-align: center; border-right: 1px solid #ccc; cursor: pointer; transition: all 0.2s ease; font-size: 13px; background: #fff; color: #000; }
    .segmented-button-section:last-child { border-right: none; }
    .segmented-button-section:hover { background: #f5f5f5; }
    .segmented-button-section:active { background: #e8e8e8; }
    .segmented-button-section.loading { opacity: 0.6; cursor: wait; pointer-events: none; }
    .segmented-button-section.ai-style { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; font-weight: 600; border-right-color: rgba(255, 255, 255, 0.3); }
    .segmented-button-section.ai-style:hover { background: linear-gradient(135deg, #5568d3 0%, #653a8f 100%); }
    .segmented-button-section.ai-style .star-icon { font-size: 14px; margin-right: 4px; display: inline-block; }
    .selectable-variants-title { font-size: 12px; color: #ffffff !important; margin-bottom: 8px; font-weight: 600; padding: 6px 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 4px; display: inline-flex; align-items: center; gap: 6px; }
    .selectable-variants-title .star-icon { font-size: 14px; color: #ffffff; }
    .selectable-variant-thumb { width: 60px; height: 60px; object-fit: cover; border-radius: 4px; background: #fafafa; cursor: pointer; border: 2px solid #667eea; transition: all 0.2s; }
    .selectable-variant-thumb:hover { border-color: #764ba2; transform: scale(1.05); box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4); }
    
    /* Responsive design */
    @media (max-width: 1024px) {
      body { margin: 12px; }
      .rowItem { grid-template-columns: 1fr; gap: 16px; }
      .main-image { max-width: 100%; }
      .btns { width: 100%; flex-direction: column; }
      .btns button { width: 100%; }
      .upload-area { padding: 24px 16px; }
      .toolbar { flex-direction: column; align-items: stretch; }
      .toolbar button { width: 100%; }
    }
    
    @media (max-width: 768px) {
      body { margin: 8px; }
      h1 { font-size: 18px; }
      h2 { font-size: 14px; }
      .rowItem { padding: 12px; }
      .live-badge, .draft-badge { font-size: 10px; padding: 3px 8px; }
    }
    .variant-thumbs { display: flex; flex-wrap: nowrap; gap: 8px; margin-top: 12px; overflow-x: auto; padding-bottom: 4px; }
    .variant-thumb-wrapper { position: relative; flex-shrink: 0; }
    .variant-thumb { width: 80px; height: 80px; object-fit: cover; border-radius: 6px; background: #fafafa; cursor: pointer; border: 2px solid transparent; display: block; }
    .variant-thumb:hover { border-color: #888; }
    .variant-thumb.active { border-color: #666; }
    .variant-thumb-delete { position: absolute; top: 4px; right: 4px; width: 18px; height: 18px; border-radius: 50%; background: #dc3545; color: #fff; border: 1px solid #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; line-height: 1; padding: 0; z-index: 10; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    .variant-thumb-delete:hover { background: #c82333; }
    .selectable-variants { margin-top: 16px; padding-top: 16px; border-top: 1px solid #eee; display: none; }
    .selectable-variants.visible { display: block; }
    .selectable-variants-grid { display: flex; flex-wrap: wrap; gap: 6px; }
    .selectable-variant-thumb:active { transform: scale(0.95); }
    .add-variant-btn { width: 80px; height: 80px; border: 2px dashed #ccc; border-radius: 6px; background: #fafafa; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 24px; color: #999; transition: all 0.2s; flex-shrink: 0; }
    .add-variant-btn:hover { border-color: #888; color: #666; background: #f0f0f0; }
    .thumb { width: 100%; aspect-ratio: 1 / 1; object-fit: cover; border-radius: 6px; background: #fafafa; }
    .row { display: flex; align-items: center; gap: 8px; }
    button { appearance: none; border: 1px solid #ccc; background: #fff; padding: 8px 12px; border-radius: 6px; cursor: pointer; }
    button.primary { background: #666; color: #fff; border-color: #666; }
    button.primary:hover { background: #555; border-color: #555; }
    .muted { color: #666; font-size: 12px; }
    .toolbar { display: flex; gap: 8px; align-items: center; justify-content: space-between; margin-top: 8px; }
    .hidden { display: none; }
    .flash { border: 1px solid #f2c6c6; background: #fff5f5; color: #8a1f1f; padding: 12px; border-radius: 8px; margin-bottom: 16px; }
    .flash.success { border-color: #bfe1c7; background: #f6fffa; color: #1f6b3a; }
    .field { display: flex; flex-direction: column; gap: 4px; margin-bottom: 8px; }
    .field label { font-size: 12px; color: #555; }
    .field input, .field textarea { width: 100%; padding: 6px 8px; border: 1px solid #ccc; border-radius: 6px; font: inherit; background: #fff; color: #000; }
    .btns { display: flex; flex-wrap: wrap; gap: 8px; }
    .toast-container { position: fixed; top: 20px; right: 20px; z-index: 10000; display: flex; flex-direction: column; gap: 8px; }
    .toast { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 12px 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 300px; max-width: 400px; animation: toastSlideIn 0.3s ease-out; }
    .toast.success { border-color: #28a745; background: #f6fffa; color: #1f6b3a; }
    .toast.error { border-color: #dc3545; background: #fff5f5; color: #8a1f1f; }
    .toast.info { border-color: #888; background: #f5f5f5; color: #333; }
    @keyframes toastSlideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes toastSlideOut {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
    .toast.hiding { animation: toastSlideOut 0.3s ease-in forwards; }
  </style>
  <script>
    // Set admin flag in localStorage when admin page loads successfully
    if (typeof Storage !== 'undefined') {
      localStorage.setItem('admin', 'true');
    }
    
    let availableVariants = [];

    async function fetchVariants() {
      try {
        const res = await fetch('variants.php?action=list');
        if (!res.ok) return [];
        const data = await res.json();
        return data.ok ? (data.variants || []) : [];
      } catch (error) {
        console.error('Error fetching variants:', error);
        return [];
      }
    }

    async function fetchImages() {
      const res = await fetch('list_images.php');
      if (!res.ok) return { images: [] };
      return res.json();
    }

    // Auto-save debounce timers for each painting
    const autoSaveTimers = new Map();
    
    function setupAutoSave(imageBaseName, imageOriginalName) {
      const row = document.getElementById(`painting-${imageBaseName}`);
      if (!row) return;
      
      const indicator = document.getElementById(`save-indicator-${imageBaseName}`);
      
      // Get all form fields
      const fields = [
        row.querySelector('input[name="title"]'),
        row.querySelector('textarea[name="description"]'),
        row.querySelector('input[name="width"]'),
        row.querySelector('input[name="height"]'),
        row.querySelector('input[name="tags"]'),
        row.querySelector('input[name="date"]'),
        row.querySelector('input[name="sold"]')
      ].filter(f => f !== null);
      
      // Function to trigger auto-save
      const triggerAutoSave = () => {
        // Clear existing timer
        if (autoSaveTimers.has(imageBaseName)) {
          clearTimeout(autoSaveTimers.get(imageBaseName));
        }
        
        // Show "Wird gespeichert..." indicator
        if (indicator) {
          indicator.textContent = 'Wird gespeichert...';
          indicator.style.color = '#666';
          indicator.style.opacity = '1';
        }
        
        // Set new timer (1.5 second delay)
        const timer = setTimeout(async () => {
          try {
            await saveMetaAuto(imageOriginalName, row, indicator);
          } catch (error) {
            console.error('Auto-save error:', error);
            if (indicator) {
              indicator.textContent = 'Fehler beim Speichern';
              indicator.style.color = '#dc3545';
              indicator.style.opacity = '1';
              setTimeout(() => {
                if (indicator) indicator.style.opacity = '0';
              }, 3000);
            }
          }
          autoSaveTimers.delete(imageBaseName);
        }, 1500);
        
        autoSaveTimers.set(imageBaseName, timer);
      };
      
      // Attach event listeners to all fields
      fields.forEach(field => {
        // Update URL immediately when field changes
        const updateURL = () => {
          updatePaintingURL(imageBaseName);
        };
        
        // Focus event - update URL when clicking/focusing on input
        field.addEventListener('focus', updateURL);
        
        // Input/change events
        field.addEventListener('input', () => {
          updateURL();
          triggerAutoSave();
        });
        field.addEventListener('change', () => {
          updateURL();
          triggerAutoSave();
        });
        
        // Paste event (for text fields)
        if (field.tagName === 'INPUT' || field.tagName === 'TEXTAREA') {
          field.addEventListener('paste', () => {
            // Small delay to let paste complete
            setTimeout(() => {
              updateURL();
              triggerAutoSave();
            }, 100);
          });
        }
      });
      
      // Helper function to check if target is an interactive element
      const isInteractiveElement = (target) => {
        return target.closest('button, input, textarea, a, img.clickable, .variant-thumb, .selectable-variant-thumb, .segmented-button-section, .variant-thumb-delete, .delete-icon, .ai-fill-button, .live-badge, .draft-badge, .add-variant-btn, .selectable-variants-title, label, .field');
      };
      
      // Add click listener to the entire row to update URL when clicking background areas
      row.addEventListener('click', (e) => {
        // Update URL when clicking on background areas (not on interactive elements)
        // This includes clicking on the image container background, form container background, etc.
        if (!isInteractiveElement(e.target)) {
          updatePaintingURL(imageBaseName);
        }
      });
    }
    
    async function saveMetaAuto(image, row, indicator) {
      const body = new FormData();
      body.set('image', image);
      body.set('title', row.querySelector('input[name="title"]').value);
      body.set('description', row.querySelector('textarea[name="description"]').value);
      body.set('width', row.querySelector('input[name="width"]').value);
      body.set('height', row.querySelector('input[name="height"]').value);
      body.set('tags', row.querySelector('input[name="tags"]').value);
      body.set('date', row.querySelector('input[name="date"]').value);
      const soldCheckbox = row.querySelector('input[name="sold"]');
      body.set('sold', soldCheckbox && soldCheckbox.checked ? '1' : '0');
      
      const res = await fetch('save_meta.php', { method: 'POST', body });
      if (!res.ok) {
        if (indicator) {
          indicator.textContent = 'Fehler beim Speichern';
          indicator.style.color = '#dc3545';
          indicator.style.opacity = '1';
        }
        return;
      }
      
      const data = await res.json().catch(() => ({}));
      if (indicator) {
        if (data.in_gallery) {
          indicator.textContent = 'Gespeichert und Live-Version aktualisiert';
        } else {
          indicator.textContent = 'Gespeichert';
        }
        indicator.style.color = '#28a745';
        indicator.style.opacity = '1';
        
        // Fade out after 2 seconds
        setTimeout(() => {
          if (indicator) indicator.style.opacity = '0';
        }, 2000);
      }
    }

    function renderImageRow(g) {
      const row = document.createElement('div');
      row.className = g.in_gallery ? 'rowItem live' : 'rowItem';
      row.id = `painting-${g.base}`;
      const meta = g.meta || {};
      const originalVariant = (g.variants.find(v => v.variant === 'original') || g.variants[0]);
      
      // Find final image
      const finalVariant = g.variants.find(v => v.variant === 'final');
      // Find variant images (those that start with "variant_")
      const imageVariants = g.variants.filter(v => v.variant && v.variant.startsWith('variant_'));
      // Extract variant names that are already added (remove "variant_" prefix)
      const addedVariantNames = new Set(
        imageVariants.map(v => {
          // Extract variant name: "variant_arbeitszimmer" -> "arbeitszimmer"
          return v.variant.replace(/^variant_/, '');
        })
      );
      // Filter available variants to exclude already added ones
      const selectableVariants = availableVariants.filter(v => {
        // Extract variant name from filename: "arbeitszimmer.jpg" -> "arbeitszimmer"
        const variantName = v.name.replace(/\.(jpg|jpeg)$/i, '');
        return !addedVariantNames.has(variantName);
      });
      // Combine: final first, then variants
      const allVariants = [];
      if (finalVariant) {
        allVariants.push(finalVariant);
      }
      allVariants.push(...imageVariants);
      
      // Add cache-busting timestamp to image URLs to ensure fresh load
      const cacheBuster = '?t=' + Date.now();
      const imageClickable = g.in_gallery && g.gallery_filename;
      // Create click handler that includes variant index (1-based: final=1, first variant=2, etc.)
      const imageClickHandler = imageClickable ? `onclick="handleImageClick('${escapeHtml(g.base)}', '${encodeURIComponent(g.gallery_filename)}')"` : '';
      const imageClass = imageClickable ? 'main-image clickable' : 'main-image';
      const badgeClickHandler = `handleBadgeClick('${escapeHtml(originalVariant.name)}', ${g.in_gallery ? 'true' : 'false'})`;
      const showSegmentedButton = finalVariant ? 'show-segmented-button' : '';
      row.innerHTML = `
        <div class="image-container">
          <div class="main-image-wrapper ${showSegmentedButton}">
            ${g.in_gallery ? `<div class="live-badge clickable" onclick="event.stopPropagation(); event.preventDefault(); ${badgeClickHandler}" title="Zur√ºck auf Entwurf">Live</div>` : `<div class="draft-badge clickable" onclick="event.stopPropagation(); event.preventDefault(); ${badgeClickHandler}" title="Live schalten">Entwurf</div>`}
            ${finalVariant ? `
              <img class="${imageClass}" id="main-img-${g.base}" loading="lazy" src="${finalVariant.url}${cacheBuster}" alt="${finalVariant.name}" ${imageClickHandler} data-variant="final">
            ` : '<div class="main-image" style="aspect-ratio: 1/1; display: flex; align-items: center; justify-content: center; color: #999;">Kein Final-Bild</div>'}
            ${finalVariant ? `
            <div class="segmented-button">
              <div class="segmented-button-section" onclick='doAction("${escapeHtml(originalVariant.name)}", "restore", this)'>Originalbild verwenden</div>
              <div class="segmented-button-section ai-style" onclick='doCorners("${escapeHtml(originalVariant.name)}", this)'><span class="star-icon">‚≠ê</span>KI Bild freistellen lassen</div>
              <div class="segmented-button-section" onclick='doManualFree("${escapeHtml(originalVariant.name)}", this)'>Bild von Hand freistellen</div>
            </div>
            ` : ''}
          </div>
          ${allVariants.length > 0 ? `
            <div class="variant-thumbs" id="thumbs-${g.base}">
              ${allVariants.map((v) => `
                <div class="variant-thumb-wrapper">
                  <img class="variant-thumb ${v.variant === 'final' ? 'active' : ''}" 
                       loading="lazy" 
                       src="${v.url}${cacheBuster}" 
                       alt="${v.name}"
                       data-variant="${v.variant || ''}"
                       onclick="selectVariantByValue('${escapeHtml(g.base)}', '${v.variant || ''}', '${v.url}')"
                       title="${v.name}">
                  ${v.variant && v.variant.startsWith('variant_') ? `
                    <button class="variant-thumb-delete" 
                            onclick="event.stopPropagation(); deleteImageVariant('${escapeHtml(v.name)}', '${escapeHtml(g.base)}', this)"
                            title="L√∂schen">√ó</button>
                  ` : ''}
                </div>
              `).join('')}
              <div class="add-variant-btn" onclick="toggleVariants('${escapeHtml(g.base)}')" title="KI Variante hinzuf√ºgen">+</div>
            </div>
          ` : `
            <div class="variant-thumbs" id="thumbs-${g.base}">
              <div class="add-variant-btn" onclick="toggleVariants('${escapeHtml(g.base)}')" title="KI Variante hinzuf√ºgen">+</div>
            </div>
          `}
          <div class="selectable-variants" id="selectable-variants-${g.base}">
            <div class="selectable-variants-title"><span class="star-icon">‚≠ê</span>KI Varianten</div>
            <div class="selectable-variants-grid" id="variants-${g.base}">
              ${selectableVariants.length > 0 ? selectableVariants.map(v => `
                <img class="selectable-variant-thumb" 
                     src="${escapeHtml(v.url)}" 
                     alt="${escapeHtml(v.name)}"
                     title="${escapeHtml(v.name)}"
                     onclick="copyVariantToImage('${escapeHtml(v.name)}', '${escapeHtml(g.base)}', ${g.in_gallery ? 'true' : 'false'}, '${escapeHtml(originalVariant.name)}', this)">
              `).join('') : '<span class="muted" style="font-size: 11px;">Keine Varianten verf√ºgbar</span>'}
            </div>
          </div>
        </div>
        <div class="form-container" style="padding-right: 8px; position: relative;">
          <button class="delete-icon" style="position: absolute; top: 0; right: 0;" onclick="event.stopPropagation(); deleteCompletely('${escapeHtml(originalVariant.name)}', this)" title="Vollst√§ndig l√∂schen">√ó</button>
          <button type="button" class="ai-fill-button" onclick='fillFormWithAI("${escapeHtml(originalVariant.name)}", this)' title="KI Formular ausf√ºllen lassen">
            <span class="star-icon">‚≠ê</span>
            <span class="short-text">KI</span>
            <span class="full-text">Formular ausf√ºllen lassen</span>
          </button>
          <div class="field">
            <label>Titel</label>
            <input type="text" name="title" value="${escapeHtml(meta.title || '')}">
          </div>
          <div class="field">
            <label>Beschreibung</label>
            <textarea name="description" rows="3">${escapeHtml(meta.description || '')}</textarea>
          </div>
          <div style="display: grid; grid-template-columns: auto auto auto; gap: 8px; align-items: end;">
            <div class="field" style="max-width: 100px;">
              <label>Breite (cm)</label>
              <input type="text" name="width" value="${escapeHtml(meta.width || '')}">
            </div>
            <div class="field" style="max-width: 100px;">
              <label>H√∂he (cm)</label>
              <input type="text" name="height" value="${escapeHtml(meta.height || '')}">
            </div>
            <div class="field" style="max-width: 120px;">
              <label>Datum (dd.mm.yyyy)</label>
              <input type="text" name="date" value="${escapeHtml(meta.date || '')}">
            </div>
          </div>
          <div class="field">
            <label>Tags</label>
            <input type="text" name="tags" value="${escapeHtml(meta.tags || '')}">
          </div>
          <div class="field">
            <label style="display: flex; align-items: center; gap: 8px;">
              <input type="checkbox" name="sold" ${meta.sold ? 'checked' : ''} style="width: auto; margin: 0;">
              Verkauft
            </label>
          </div>
          ${meta.manual_corners && Array.isArray(meta.manual_corners) && meta.manual_corners.length === 4 ? `
          <div class="field" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee;">
            <label style="font-size: 11px; color: #666; margin-bottom: 4px;">Manuelle Ecken-Positionen:</label>
            <div style="font-size: 11px; color: #888; font-family: monospace;">
              Oben links: (${meta.manual_corners[0][0]}, ${meta.manual_corners[0][1]})<br>
              Oben rechts: (${meta.manual_corners[1][0]}, ${meta.manual_corners[1][1]})<br>
              Unten rechts: (${meta.manual_corners[2][0]}, ${meta.manual_corners[2][1]})<br>
              Unten links: (${meta.manual_corners[3][0]}, ${meta.manual_corners[3][1]})
            </div>
          </div>
          ` : ''}
          <div class="auto-save-indicator" id="save-indicator-${g.base}" style="font-size: 11px; color: #666; margin-top: 8px; opacity: 0; transition: opacity 0.3s ease;"></div>
        </div>
      `;
      
      // Store allVariants array on the row for later access (including URLs)
      row.dataset.variants = JSON.stringify(allVariants.map(v => ({ 
        variant: v.variant || '', 
        name: v.name,
        url: v.url
      })));
      
      // Store painting identifier for URL updates
      row.dataset.paintingBase = g.base;
      row.dataset.paintingGalleryFilename = g.gallery_filename || '';
      row.dataset.paintingInGallery = g.in_gallery ? 'true' : 'false';
      
      // Set up auto-save for this row after it's added to DOM
      setTimeout(() => {
        setupAutoSave(g.base, originalVariant.name);
      }, 0);
      
      return row;
    }

    function getVariantIndex(imageBaseName, variantValue) {
      const row = document.getElementById(`painting-${imageBaseName}`);
      if (!row || !row.dataset.variants) return 1; // Default to 1 (final)
      
      try {
        const variants = JSON.parse(row.dataset.variants);
        // Find index of variant (1-based: final=1, first variant=2, etc.)
        const index = variants.findIndex(v => v.variant === variantValue);
        return index >= 0 ? index + 1 : 1; // Return 1-based index, default to 1 if not found
      } catch (e) {
        return 1;
      }
    }

    function updatePaintingURL(imageBaseName) {
      const row = document.getElementById(`painting-${imageBaseName}`);
      if (!row) return;
      
      // Get painting identifier (prefer gallery_filename, fallback to base)
      const galleryFilename = row.dataset.paintingGalleryFilename;
      const base = row.dataset.paintingBase || imageBaseName;
      const paintingId = galleryFilename || base;
      
      // Get current variant
      const mainImg = document.getElementById(`main-img-${imageBaseName}`);
      if (!mainImg) return;
      
      const currentVariant = mainImg.getAttribute('data-variant') || 'final';
      const variantIndex = getVariantIndex(imageBaseName, currentVariant);
      
      // Update URL without reloading
      const newUrl = new URL(window.location);
      newUrl.searchParams.set('painting', paintingId);
      newUrl.searchParams.set('variant', variantIndex.toString());
      
      // Use replaceState to avoid adding to history
      window.history.replaceState({}, '', newUrl);
    }

    function handleImageClick(imageBaseName, galleryFilename) {
      const mainImg = document.getElementById(`main-img-${imageBaseName}`);
      if (!mainImg) return;
      
      const currentVariant = mainImg.getAttribute('data-variant') || 'final';
      const variantIndex = getVariantIndex(imageBaseName, currentVariant);
      
      // Navigate with variant parameter (1-based index)
      const url = `/index.html?painting=${encodeURIComponent(galleryFilename)}&variant=${variantIndex}`;
      window.location.href = url;
    }

    function selectVariantByValue(imageBaseName, variantValue, variantUrl) {
      const mainImg = document.getElementById(`main-img-${imageBaseName}`);
      const thumbs = document.getElementById(`thumbs-${imageBaseName}`);
      const wrapper = mainImg ? mainImg.closest('.main-image-wrapper') : null;
      
      if (!mainImg || !thumbs) return;
      
      // Update main image
      mainImg.src = variantUrl.split('?')[0] + '?t=' + Date.now();
      mainImg.setAttribute('data-variant', variantValue || '');
      
      // Update active state on thumbs
      const thumbElements = thumbs.querySelectorAll('.variant-thumb');
      thumbElements.forEach(thumb => {
        if (thumb.getAttribute('data-variant') === variantValue) {
          thumb.classList.add('active');
        } else {
          thumb.classList.remove('active');
        }
      });
      
      // Update segmented button visibility
      if (wrapper) {
        if (variantValue === 'final') {
          wrapper.classList.add('show-segmented-button');
        } else {
          wrapper.classList.remove('show-segmented-button');
        }
      }
      
      // Update URL
      updatePaintingURL(imageBaseName);
    }

    function selectVariant(imageBaseName, variantIndex) {
      const row = document.getElementById(`painting-${imageBaseName}`);
      if (!row || !row.dataset.variants) return;
      
      try {
        const variants = JSON.parse(row.dataset.variants);
        // variantIndex is 1-based, convert to 0-based
        const index = variantIndex - 1;
        if (index < 0 || index >= variants.length) return;
        
        const variant = variants[index];
        const mainImg = document.getElementById(`main-img-${imageBaseName}`);
        const thumbs = document.getElementById(`thumbs-${imageBaseName}`);
        const wrapper = mainImg ? mainImg.closest('.main-image-wrapper') : null;
        
        if (!mainImg || !thumbs || !variant) return;
        
        // Update main image with the variant URL
        const variantUrl = variant.url.split('?')[0] + '?t=' + Date.now();
        mainImg.src = variantUrl;
        mainImg.setAttribute('data-variant', variant.variant || '');
        
        // Update active state on thumbs
        const thumbElements = thumbs.querySelectorAll('.variant-thumb');
        thumbElements.forEach((thumb, idx) => {
          if (idx === index) {
            thumb.classList.add('active');
          } else {
            thumb.classList.remove('active');
          }
        });
        
        // Update segmented button visibility
        if (wrapper) {
          if (variant.variant === 'final') {
            wrapper.classList.add('show-segmented-button');
          } else {
            wrapper.classList.remove('show-segmented-button');
          }
        }
        
        // Update URL
        updatePaintingURL(imageBaseName);
      } catch (e) {
        console.error('Error selecting variant:', e);
      }
    }

    function renderImages(groups) {
      const container = document.getElementById('images');
      container.innerHTML = '';
      if (!groups.length) {
        container.innerHTML = '<p class="muted">Noch keine Bilder vorhanden.</p>';
        return;
      }

      for (const g of groups) {
        const row = renderImageRow(g);
        container.appendChild(row);
      }
    }

    async function refresh() {
      // Fetch variants first
      availableVariants = await fetchVariants();
      
      const { groups } = await fetchImages();
      renderImages(groups);
      
      // Check for painting parameter in URL and scroll to it
      const urlParams = new URLSearchParams(window.location.search);
      const paintingParam = urlParams.get('painting');
      const variantParam = urlParams.get('variant');
      if (paintingParam) {
        // Try to find by gallery_filename first, then fallback to base
        let targetElement = null;
        let targetBase = null;
        for (const g of groups) {
          if (g.gallery_filename && g.gallery_filename.toLowerCase() === paintingParam.toLowerCase()) {
            targetElement = document.getElementById(`painting-${g.base}`);
            targetBase = g.base;
            break;
          }
          if (g.base.toLowerCase() === paintingParam.toLowerCase()) {
            targetElement = document.getElementById(`painting-${g.base}`);
            targetBase = g.base;
            break;
          }
        }
        if (targetElement) {
          setTimeout(() => {
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
            // Highlight the element briefly
            targetElement.style.transition = 'box-shadow 0.3s ease';
            targetElement.style.boxShadow = '0 0 0 4px rgba(11, 95, 255, 0.5)';
            setTimeout(() => {
              targetElement.style.boxShadow = '';
            }, 2000);
            
            // Select variant if parameter is present
            if (variantParam && targetBase) {
              const variantIndex = parseInt(variantParam, 10);
              if (!isNaN(variantIndex) && variantIndex > 0) {
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                  selectVariant(targetBase, variantIndex);
                }, 200);
              }
            }
          }, 100);
        }
      }
    }

    async function deleteImageVariant(filename, imageBaseName, btn) {
      if (!confirm('M√∂chten Sie diese Variante wirklich l√∂schen?')) {
        return;
      }

      const prev = btn.textContent;
      btn.disabled = true;
      btn.style.opacity = '0.5';

      try {
        const body = new FormData();
        body.set('filename', filename);

        const res = await fetch('delete_image_variant.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('L√∂schen fehlgeschlagen: ' + msg, 'error');
          return;
        }

        const data = await res.json();
        if (!data.ok) {
          showToast('L√∂schen fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }

        showToast('Variante erfolgreich gel√∂scht', 'success');
        refresh();
      } catch (error) {
        showToast('Fehler: ' + error.message, 'error');
      } finally {
        btn.disabled = false;
        btn.style.opacity = '';
      }
    }

    async function copyVariantToImage(variantFilename, imageBaseName, isLive, originalImageName, thumbElement) {
      // Update URL when interacting with variant generation
      updatePaintingURL(imageBaseName);
      
      const prevOpacity = thumbElement.style.opacity;
      thumbElement.style.opacity = '0.5';
      thumbElement.style.cursor = 'wait';
      showToast('KI generiert Variante...', 'info', 300000); // 5 minutes max

      try {
        // Get width and height from the form fields
        const row = document.getElementById(`painting-${imageBaseName}`);
        const width = row ? (row.querySelector('input[name="width"]')?.value || '').trim() : '';
        const height = row ? (row.querySelector('input[name="height"]')?.value || '').trim() : '';
        
        const body = new FormData();
        body.set('action', 'copy_to_image');
        body.set('variant_filename', variantFilename);
        body.set('image_base_name', imageBaseName);
        if (width) body.set('width', width);
        if (height) body.set('height', height);

        const res = await fetch('variants.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Fehler beim Generieren: ' + msg, 'error');
          return;
        }

        const data = await res.json();
        if (!data.ok) {
          showToast('Fehler beim Generieren: ' + (data.error || 'Unknown'), 'error');
          return;
        }

        // If image is live, copy to gallery
        if (isLive) {
          showToast('Variante generiert. Aktualisiere Live-Version...', 'info');
          try {
            const copyBody = new FormData();
            copyBody.set('image', originalImageName);
            const copyRes = await fetch('copy_to_gallery.php', { method: 'POST', body: copyBody });
            if (!copyRes.ok) {
              const copyMsg = await copyRes.text();
              showToast('Variante generiert, aber Live-Aktualisierung fehlgeschlagen: ' + copyMsg, 'error');
              // Still update the UI even if copy failed
              await updateImageRow(imageBaseName);
              return;
            }
            const copyData = await copyRes.json().catch(() => ({}));
            if (!copyData.ok) {
              showToast('Variante generiert, aber Live-Aktualisierung fehlgeschlagen: ' + (copyData.error || 'Unknown'), 'error');
              // Still update the UI even if copy failed
              await updateImageRow(imageBaseName);
              return;
            }
            showToast('Variante erfolgreich generiert und Live-Version aktualisiert', 'success');
          } catch (copyError) {
            showToast('Variante generiert, aber Live-Aktualisierung fehlgeschlagen: ' + copyError.message, 'error');
            // Still update the UI even if copy failed
            await updateImageRow(imageBaseName);
            return;
          }
        } else {
          showToast('Variante erfolgreich generiert', 'success');
        }

        // Update only the affected image row instead of full page reload
        await updateImageRow(imageBaseName);
      } catch (error) {
        showToast('Fehler: ' + error.message, 'error');
      } finally {
        thumbElement.style.opacity = prevOpacity || '';
        thumbElement.style.cursor = '';
      }
    }

    async function updateImageRow(imageBaseName) {
      // Fetch updated image data
      const { groups } = await fetchImages();
      const updatedGroup = groups.find(g => g.base === imageBaseName);
      
      if (!updatedGroup) {
        // If image not found, do full refresh as fallback
        refresh();
        return;
      }

      // Find the existing row element
      const existingRow = document.getElementById(`painting-${imageBaseName}`);
      if (!existingRow) {
        // If row not found, do full refresh as fallback
        refresh();
        return;
      }

      // Fetch variants first to ensure they're available
      availableVariants = await fetchVariants();

      // Render the new row
      const newRow = renderImageRow(updatedGroup);
      
      // Replace the old row with the new one
      existingRow.replaceWith(newRow);
      
      // Set up auto-save for the new row
      if (updatedGroup) {
        const originalVariant = (updatedGroup.variants.find(v => v.variant === 'original') || updatedGroup.variants[0]);
        setupAutoSave(imageBaseName, originalVariant.name);
      }
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;'}[c]));
    }

    function toggleVariants(imageBaseName) {
      const variantsSection = document.getElementById(`selectable-variants-${imageBaseName}`);
      if (variantsSection) {
        variantsSection.classList.toggle('visible');
        // Update URL when interacting with variants
        updatePaintingURL(imageBaseName);
      }
    }

    async function handleBadgeClick(imageOriginalName, isLive) {
      // Extract imageBaseName and update URL
      const base = imageOriginalName.replace(/_variant_[^_]+\.(jpg|jpeg|png)$/i, '').replace(/_(original|color|final)\.(jpg|jpeg|png)$/i, '').replace(/\.(jpg|jpeg|png)$/i, '');
      updatePaintingURL(base);
      
      if (isLive) {
        await removeFromGallery(imageOriginalName, {});
      } else {
        await copyToGallery(imageOriginalName, {});
      }
    }

    function showToast(message, type = 'info', duration = 3000) {
      const container = document.getElementById('toastContainer');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      container.appendChild(toast);
      
      // Limit duration to maximum 20 seconds
      const maxDuration = 20000;
      const actualDuration = Math.min(duration, maxDuration);
      
      setTimeout(() => {
        toast.classList.add('hiding');
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 300);
      }, actualDuration);
    }

    window.addEventListener('DOMContentLoaded', () => {
      showFlashFromQuery();
      refresh();
      
      const fileInput = document.getElementById('fileInput');
      const uploadArea = document.getElementById('uploadArea');
      const uploadForm = document.getElementById('uploadForm');
      
      // Click on upload area to trigger file input
      uploadArea.addEventListener('click', () => {
        fileInput.click();
      });
      
      // File input change handler
      fileInput.addEventListener('change', async (e) => {
        if (!fileInput.files || fileInput.files.length === 0) return;
        await uploadFiles(fileInput.files);
      }, { passive: true });
      
      // Drag and drop handlers
      uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.add('dragover');
      });
      
      uploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.remove('dragover');
      });
      
      uploadArea.addEventListener('drop', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.remove('dragover');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          await uploadFiles(files);
        }
      });
      
      async function uploadFiles(files) {
        const fd = new FormData(uploadForm);
        // Clear existing files and add dropped files
        for (let i = 0; i < files.length; i++) {
          fd.append('images[]', files[i]);
        }
        
        try {
          const res = await fetch('upload.php', { method: 'POST', body: fd });
          if (res.ok) {
            showToast(`${files.length} Bild(er) erfolgreich hochgeladen`, 'success');
          } else {
            showToast('Fehler beim Hochladen', 'error');
          }
        } catch (error) {
          showToast('Fehler beim Hochladen: ' + error.message, 'error');
        }
        
        fileInput.value = '';
        refresh();
      }
    });
  </script>
  <noscript>Please enable JavaScript to view and select images.</noscript>
  <meta name="robots" content="noindex, nofollow">
  <meta http-equiv="Cache-Control" content="no-store" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <link rel="icon" href="data:,">
  <title>Administration der Herzfabrik</title>
  </head>
<body>
  <div id="toastContainer" class="toast-container"></div>
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; flex-wrap: wrap; gap: 12px;">
    <h1 style="margin: 0;">Administration der <a href="/index.html" id="site-domain-link" style="color: #DC143C; text-decoration: none;">Herzfabrik</a></h1>
    <div style="display: flex; gap: 12px; align-items: center;">
      <a href="index.html" style="color: #555; text-decoration: none; font-size: 14px; padding: 6px 12px; border: 1px solid #888; border-radius: 6px; background: #f5f5f5;">Gem√§lde</a>
      <a href="variants.html" style="color: #555; text-decoration: none; font-size: 14px; padding: 6px 12px; border: 1px solid #888; border-radius: 6px;">Raum-Mockups</a>
      <a href="artist.html" style="color: #555; text-decoration: none; font-size: 14px; padding: 6px 12px; border: 1px solid #888; border-radius: 6px;">K√ºnstler</a>
    </div>
  </div>
  <div id="flash" class="flash hidden"></div>

  <div class="">
    <h2>Gem√§lde hochladen</h2>
    <form id="uploadForm" action="/admin/upload.php" method="post" enctype="multipart/form-data">
      <div id="uploadArea" class="upload-area">
        <div class="upload-area-text">üì∑ Bilder hier ablegen oder klicken zum Ausw√§hlen</div>
        <div class="upload-area-hint">Sie k√∂nnen mehrere Bilder gleichzeitig hochladen</div>
        <input type="file" name="images[]" accept="image/*" multiple required style="display: none;" id="fileInput">
      </div>
    </form>
  </div>

  <div class="">
    <div class="toolbar">
      <h2>Gem√§lde</h2>
    </div>
    <div id="images" class="list"></div>
  </div>

  <script>
    function showFlashFromQuery() {
      const url = new URL(window.location.href);
      const processed = url.searchParams.get('processed');
      const errors = url.searchParams.get('errors');
      const errorsDetailRaw = url.searchParams.get('errors_detail');
      if (!processed && !errors) return;
      const box = document.getElementById('flash');
      box.classList.remove('hidden');
      const p = parseInt(processed || '0', 10);
      const e = parseInt(errors || '0', 10);
      let html = '';
      if (e > 0) {
        box.classList.remove('success');
        html += `<strong>Processing finished:</strong> ${p} succeeded, ${e} failed.`;
        if (errorsDetailRaw) {
          try {
            const details = JSON.parse(errorsDetailRaw);
            if (Array.isArray(details) && details.length) {
              html += '<div style="margin-top:8px"><strong>Errors:</strong><ul>' +
                details.map(d => `<li>${String(d)}</li>`).join('') + '</ul></div>';
            }
          } catch {}
        }
      } else {
        box.classList.add('success');
        html += `<strong>Success:</strong> Processed ${p} image(s).`;
      }
      box.innerHTML = html;
      // Clean params from URL without reloading
      window.history.replaceState({}, '', url.pathname);
    }

    async function saveMeta(image, btn) {
      const item = btn.closest('.rowItem');
      const body = new FormData();
      body.set('image', image);
      body.set('title', item.querySelector('input[name=\"title\"]').value);
      body.set('description', item.querySelector('textarea[name=\"description\"]').value);
      body.set('width', item.querySelector('input[name=\"width\"]').value);
      body.set('height', item.querySelector('input[name=\"height\"]').value);
      body.set('tags', item.querySelector('input[name=\"tags\"]').value);
      body.set('date', item.querySelector('input[name=\"date\"]').value);
      const soldCheckbox = item.querySelector('input[name=\"sold\"]');
      body.set('sold', soldCheckbox && soldCheckbox.checked ? '1' : '0');
      btn.disabled = true;
      const res = await fetch('save_meta.php', { method: 'POST', body });
      btn.disabled = false;
      if (!res.ok) {
        showToast('Fehler beim Speichern der Metadaten', 'error');
        return;
      }
      const data = await res.json().catch(() => ({}));
      if (data.in_gallery) {
        showToast('Metadaten gespeichert und Live-Version aktualisiert', 'success');
        // Refresh to update button state
        refresh();
      } else {
        showToast('Metadaten gespeichert', 'success');
      }
    }

    async function doAction(image, action, btn) {
      // Extract imageBaseName and update URL
      const row = btn.closest ? btn.closest('.rowItem') : null;
      const imageBaseName = row ? row.dataset.paintingBase : null;
      if (imageBaseName) {
        updatePaintingURL(imageBaseName);
      }
      
      if (btn.disabled !== undefined) {
        btn.disabled = true;
      } else {
        btn.classList.add('loading');
      }
      const prevText = btn.textContent;
      if (action === 'restore' && btn.textContent !== undefined) {
        btn.textContent = 'Wird kopiert‚Ä¶';
      }
      
      const body = new FormData();
      body.set('image', image);
      body.set('action', action);
      
      try {
        const res = await fetch('action.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Fehler: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('Fehler: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        
        if (action === 'restore') {
          showToast('Originalbild wird geladen‚Ä¶', 'info');
          
          // Extract base name: remove _original, _color, _final, or _variant_* suffix and extension
          const base = image.replace(/_variant_[^_]+\.(jpg|jpeg|png)$/i, '').replace(/_(original|color|final)\.(jpg|jpeg|png)$/i, '').replace(/\.(jpg|jpeg|png)$/i, '');
          
          // Wait a bit for the file copy operation to complete on the server
          await new Promise(resolve => setTimeout(resolve, 300));
          
          // Update only the affected image row instead of full page reload
          await updateImageRow(base);
          
          // Wait for the DOM to be updated
          await new Promise(resolve => setTimeout(resolve, 50));
          
          // Find the main image and wait for it to load
          const mainImg = document.getElementById(`main-img-${base}`);
          if (mainImg) {
            // Show loading state
            mainImg.style.opacity = '0.5';
            mainImg.style.transition = 'opacity 0.3s ease';
            
            // Get the base URL without query string
            const baseUrl = mainImg.src.split('?')[0];
            const freshUrl = baseUrl + '?t=' + Date.now();
            
            // Preload the image to ensure it's ready before showing it
            await new Promise((resolve) => {
              // Check if image is already complete
              if (mainImg.complete && mainImg.naturalWidth > 0) {
                // Image is already loaded, just update src and show
                mainImg.src = freshUrl;
                mainImg.style.opacity = '1';
                showToast('Originalbild erfolgreich verwendet', 'success');
                resolve();
                return;
              }
              
              // Preload the image
              const img = new Image();
              img.onload = () => {
                // Image is loaded, now update the displayed image
                mainImg.src = freshUrl;
                mainImg.style.opacity = '1';
                showToast('Originalbild erfolgreich verwendet', 'success');
                resolve();
              };
              img.onerror = () => {
                // Retry once after a short delay
                setTimeout(() => {
                  const retryImg = new Image();
                  retryImg.onload = () => {
                    mainImg.src = freshUrl;
                    mainImg.style.opacity = '1';
                    showToast('Originalbild erfolgreich verwendet', 'success');
                    resolve();
                  };
                  retryImg.onerror = () => {
                    mainImg.style.opacity = '1';
                    showToast('Originalbild verwendet, aber Bild konnte nicht geladen werden. Bitte Seite aktualisieren.', 'error');
                    resolve(); // Still resolve to not block
                  };
                  retryImg.src = freshUrl;
                }, 500);
              };
              img.src = freshUrl;
            });
          } else {
            // Fallback: full refresh if image element not found
            await refresh();
            showToast('Originalbild erfolgreich verwendet', 'success');
          }
        } else {
          await refresh();
        }
      } finally {
        if (btn.disabled !== undefined) {
          btn.disabled = false;
        } else {
          btn.classList.remove('loading');
        }
        if (btn.textContent !== undefined) btn.textContent = prevText;
      }
    }

    async function doCorners(imageOriginalName, btn) {
      // Extract imageBaseName and update URL
      const row = btn.closest ? btn.closest('.rowItem') : null;
      const imageBaseName = row ? row.dataset.paintingBase : null;
      if (imageBaseName) {
        updatePaintingURL(imageBaseName);
      }
      
      const prev = btn.textContent;
      if (btn.disabled !== undefined) {
        btn.disabled = true;
      } else {
        btn.classList.add('loading');
      }
      if (btn.textContent !== undefined) btn.textContent = 'KI‚Ä¶';
      try {
        const body = new FormData();
        body.set('image_path', 'admin/images/' + imageOriginalName);
        body.set('color', '#ffffff');
        const res = await fetch('corners.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('KI-Verarbeitung fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('KI-Verarbeitung fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        showToast('KI-Verarbeitung erfolgreich abgeschlossen', 'success');
        // Extract base name: remove _original, _color, _final, or _variant_* suffix and extension
        const base = imageOriginalName.replace(/_variant_[^_]+\.(jpg|jpeg|png)$/i, '').replace(/_(original|color|final)\.(jpg|jpeg|png)$/i, '').replace(/\.(jpg|jpeg|png)$/i, '');
        await refresh();
        // Force reload the main image after refresh with a small delay to ensure DOM is ready
        setTimeout(() => {
          const mainImg = document.getElementById(`main-img-${base}`);
          if (mainImg) {
            // Force reload by adding/updating cache-busting parameter
            const currentSrc = mainImg.src;
            const separator = currentSrc.includes('?') ? '&' : '?';
            mainImg.src = currentSrc.split('?')[0] + separator + 't=' + Date.now();
          }
        }, 100);
      } finally {
        if (btn.disabled !== undefined) {
          btn.disabled = false;
        } else {
          btn.classList.remove('loading');
        }
        if (btn.textContent !== undefined) btn.textContent = prev;
      }
    }

    function doManualFree(imageOriginalName, btn) {
      // Extract base name: remove _original, _color, _final, or _variant_* suffix and extension
      const base = imageOriginalName.replace(/_variant_[^_]+\.(jpg|jpeg|png)$/i, '').replace(/_(original|color|final)\.(jpg|jpeg|png)$/i, '').replace(/\.(jpg|jpeg|png)$/i, '');
      window.location.href = `free.html?painting=${encodeURIComponent(base)}`;
    }

    async function fillFormWithAI(imageOriginalName, btn) {
      const prev = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'KI‚Ä¶';
      try {
        const item = btn.closest('.rowItem');
        const imageBaseName = item ? item.dataset.paintingBase : null;
        if (imageBaseName) {
          updatePaintingURL(imageBaseName);
        }
        
        // Find the final image URL to log
        const mainImg = item.querySelector('.main-image');
        const imageUrl = mainImg ? mainImg.src : 'images/' + imageOriginalName;
        console.log('KI Formular ausf√ºllen: Verwende Bild:', imageUrl);
        
        const body = new FormData();
        body.set('image', imageOriginalName);
        const res = await fetch('ai_fill_form.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('KI-Formularausf√ºllung fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('KI-Formularausf√ºllung fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        
        // Check for warning
        if (data.warning) {
          showToast(data.warning, 'error');
          return;
        }
        
        // Fill form fields with AI-generated data
        let filled = false;
        if (data.title) {
          item.querySelector('input[name="title"]').value = data.title;
          filled = true;
        }
        if (data.description) {
          item.querySelector('textarea[name="description"]').value = data.description;
          filled = true;
        }
        if (data.tags) {
          item.querySelector('input[name="tags"]').value = data.tags;
          filled = true;
        }
        if (data.date) {
          item.querySelector('input[name="date"]').value = data.date;
          filled = true;
        }
        if (data.width) {
          item.querySelector('input[name="width"]').value = data.width;
          filled = true;
        }
        if (data.height) {
          item.querySelector('input[name="height"]').value = data.height;
          filled = true;
        }
        
        if (filled) {
          showToast('Formular erfolgreich von KI ausgef√ºllt', 'success');
          // Automatically save the form using auto-save
          // Trigger input events to activate auto-save
          const fields = [
            item.querySelector('input[name="title"]'),
            item.querySelector('textarea[name="description"]'),
            item.querySelector('input[name="width"]'),
            item.querySelector('input[name="height"]'),
            item.querySelector('input[name="tags"]'),
            item.querySelector('input[name="date"]')
          ].filter(f => f !== null);
          fields.forEach(field => {
            field.dispatchEvent(new Event('input', { bubbles: true }));
          });
        } else {
          showToast('Keine Daten von KI erhalten', 'error');
        }
      } finally {
        btn.disabled = false;
        btn.textContent = prev;
      }
    }

    async function copyToGallery(imageOriginalName, btn) {
      const prev = btn.textContent;
      if (btn.disabled !== undefined) btn.disabled = true;
      if (btn.textContent !== undefined) btn.textContent = 'Schalte live‚Ä¶';
      try {
        const body = new FormData();
        body.set('image', imageOriginalName);
        const res = await fetch('copy_to_gallery.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Live schalten fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('Live schalten fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        showToast('Erfolgreich live geschaltet', 'success');
        refresh();
      } finally {
        if (btn.disabled !== undefined) btn.disabled = false;
        if (btn.textContent !== undefined) btn.textContent = prev;
      }
    }

    async function removeFromGallery(imageOriginalName, btn) {
      const prev = btn.textContent;
      if (btn.disabled !== undefined) btn.disabled = true;
      if (btn.textContent !== undefined) btn.textContent = 'Entferne live‚Ä¶';
      try {
        const body = new FormData();
        body.set('image', imageOriginalName);
        const res = await fetch('remove_from_gallery.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Live entfernen fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('Live entfernen fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        showToast('Erfolgreich live entfernt', 'success');
        refresh();
      } finally {
        if (btn.disabled !== undefined) btn.disabled = false;
        if (btn.textContent !== undefined) btn.textContent = prev;
      }
    }

    async function deleteCompletely(imageOriginalName, btn) {
      if (!confirm('M√∂chten Sie wirklich alle Dateien dieses Gem√§ldes l√∂schen? Dies kann nicht r√ºckg√§ngig gemacht werden.')) {
        return;
      }
      const prev = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'L√∂sche‚Ä¶';
      try {
        const body = new FormData();
        body.set('image', imageOriginalName);
        const res = await fetch('delete_completely.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('L√∂schen fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('L√∂schen fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        showToast('Alle Dateien erfolgreich gel√∂scht', 'success');
        refresh();
      } finally {
        btn.disabled = false;
        btn.textContent = prev;
      }
    }
    
    // Update site domain link in header
    async function updateSiteDomainLink() {
      try {
        const res = await fetch('get_artist_content.php');
        if (!res.ok) return;
        const data = await res.json();
        if (data.ok && data.domain) {
          const domainLink = document.getElementById('site-domain-link');
          if (domainLink) {
            // Capitalize first letter
            const domainText = data.domain.charAt(0).toUpperCase() + data.domain.slice(1);
            domainLink.textContent = domainText;
          }
        }
      } catch (error) {
        // Silently fail - keep default "Herzfabrik"
      }
    }
    
    // Update domain link on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', updateSiteDomainLink);
    } else {
      updateSiteDomainLink();
    }
  </script>
</body>
</html>


