<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light">
  <title>Administration der Herzfabrik</title>
  <style>
    html { color-scheme: light; background: #fff; }
    body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; background: #fff; color: #000; }
    h1 { font-size: 20px; margin: 0 0 16px; color: #000; }
    h2 { font-size: 16px; margin: 24px 0 12px; color: #000; }
    .upload-area { border: 3px dashed #888; border-radius: 12px; padding: 32px; background: #f5f5f5; text-align: center; transition: all 0.3s ease; cursor: pointer; }
    .upload-area:hover { background: #e8e8e8; border-color: #666; }
    .upload-area.dragover { background: #ddd; border-color: #666; border-style: solid; }
    .upload-area-text { color: #555; font-weight: 500; margin-bottom: 8px; }
    .upload-area-hint { color: #666; font-size: 13px; }
    .list { display: flex; flex-direction: column; gap: 12px; }
    .rowItem { display: grid; grid-template-columns: 300px 1fr; gap: 24px; border: 1px solid #eee; border-radius: 8px; padding: 16px; align-items: start; position: relative; background: #fff; }
    .rowItem.live { border-color: #28a745; background: #f6fffa; }
    .image-container { position: relative; width: 100%; max-width: 300px; }
    .main-image-wrapper { position: relative; width: 100%; max-width: 300px; }
    .admin-frame-preview { background: #f5f5f5; padding: 12px; border-radius: 2px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.5); border: none; transition: all 0.3s ease; }
    .admin-frame-preview.frame-white { background: #f8f8f8; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12), 0 2px 4px rgba(0, 0, 0, 0.08), inset 0 0 0 1px rgba(255, 255, 255, 0.8); }
    .admin-frame-preview.frame-black { background: #1a1a1a; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.3), inset 0 0 0 1px rgba(255, 255, 255, 0.05), inset 0 1px 0 rgba(255, 255, 255, 0.08); }
    .admin-frame-preview.frame-wood { background: #c19a6b; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25), 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.15), inset 0 -1px 0 rgba(0, 0, 0, 0.25), inset 0 0 0 1px rgba(139, 111, 71, 0.3); position: relative; }
    .admin-frame-preview.frame-wood::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(ellipse at 20% 30%, rgba(139, 111, 71, 0.15) 0%, transparent 50%), radial-gradient(ellipse at 80% 70%, rgba(193, 154, 107, 0.2) 0%, transparent 50%), linear-gradient(90deg, transparent 0%, rgba(139, 111, 71, 0.08) 25%, transparent 50%, rgba(139, 111, 71, 0.08) 75%, transparent 100%); pointer-events: none; }
    .admin-frame-preview.frame-gold { background: radial-gradient(ellipse at top, rgba(255, 255, 255, 0.3) 0%, transparent 50%), linear-gradient(135deg, #f5d76e 0%, #d4af37 30%, #b8941f 60%, #d4af37 100%); border: none; box-shadow: 0 4px 12px rgba(184, 148, 31, 0.35), 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.4), inset 0 -1px 0 rgba(0, 0, 0, 0.25), inset 0 0 15px rgba(212, 175, 55, 0.2); }
    .admin-frame-preview.frame-silver { background: linear-gradient(135deg, #f0f0f0 0%, #d0d0d0 25%, #b0b0b0 50%, #d0d0d0 75%, #f0f0f0 100%), linear-gradient(45deg, rgba(255, 255, 255, 0.3) 0%, transparent 50%); border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25), 0 2px 4px rgba(0, 0, 0, 0.18), inset 0 1px 0 rgba(255, 255, 255, 0.7), inset 0 -1px 0 rgba(0, 0, 0, 0.2), inset 0 0 10px rgba(112, 112, 112, 0.1); }
    .admin-frame-preview.frame-walnut { background: #5c4033; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), 0 2px 4px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.08), inset 0 -1px 0 rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(61, 42, 34, 0.4); position: relative; }
    .admin-frame-preview.frame-walnut::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(ellipse at 25% 40%, rgba(61, 42, 34, 0.2) 0%, transparent 45%), radial-gradient(ellipse at 75% 60%, rgba(92, 64, 51, 0.15) 0%, transparent 45%), linear-gradient(90deg, transparent 0%, rgba(61, 42, 34, 0.1) 30%, transparent 60%, rgba(61, 42, 34, 0.1) 100%); pointer-events: none; }
    .admin-frame-preview.frame-oak { background: #d4a574; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.22), 0 2px 4px rgba(0, 0, 0, 0.18), inset 0 1px 0 rgba(255, 255, 255, 0.2), inset 0 -1px 0 rgba(0, 0, 0, 0.2), inset 0 0 0 1px rgba(184, 150, 106, 0.25); position: relative; }
    .admin-frame-preview.frame-oak::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(ellipse at 30% 25%, rgba(184, 150, 106, 0.12) 0%, transparent 50%), radial-gradient(ellipse at 70% 75%, rgba(212, 165, 116, 0.15) 0%, transparent 50%), linear-gradient(90deg, transparent 0%, rgba(184, 150, 106, 0.06) 35%, transparent 65%, rgba(184, 150, 106, 0.06) 100%); pointer-events: none; }
    .admin-frame-preview.frame-ornate-gold { background: radial-gradient(ellipse at 30% 30%, rgba(255, 255, 255, 0.4) 0%, transparent 40%), radial-gradient(ellipse at 70% 70%, rgba(0, 0, 0, 0.1) 0%, transparent 40%), linear-gradient(135deg, #ffd700 0%, #ffed4e 20%, #d4af37 40%, #b8941f 60%, #d4af37 80%, #ffd700 100%); border: none; box-shadow: 0 4px 12px rgba(184, 148, 31, 0.4), 0 2px 4px rgba(0, 0, 0, 0.25), inset 0 2px 0 rgba(255, 255, 255, 0.5), inset 0 -2px 0 rgba(0, 0, 0, 0.3), inset 0 0 20px rgba(212, 175, 55, 0.25), 0 0 0 1px rgba(157, 122, 26, 0.3); }
    .admin-frame-preview.frame-natural { background: #f5f0e8; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.08), inset 0 0 0 1px rgba(255, 255, 255, 0.9), inset 0 1px 2px rgba(0, 0, 0, 0.05); }
    .admin-frame-preview.frame-none { background: transparent; padding: 0; border: none; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1); }
    .admin-frame-preview .main-image { width: 100%; display: block; }
    .live-badge { position: absolute; top: 20px; left: 20px; background: #28a745; color: #fff; padding: 8px 16px; border-radius: 12px; font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; z-index: 100; }
    .live-badge.clickable { cursor: pointer; transition: all 0.2s ease; }
    .live-badge.clickable:hover { background: #218838; transform: scale(1.05); }
    .draft-badge { position: absolute; top: 20px; left: 20px; background: #ffc107; color: #000; padding: 8px 16px; border-radius: 12px; font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; z-index: 100; }
    .draft-badge.clickable { cursor: pointer; transition: all 0.2s ease; }
    .draft-badge.clickable:hover { background: #e0a800; transform: scale(1.05); }
    .ai-pending-badge { position: absolute; top: 8px; left: 8px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; padding: 10px 16px; border-radius: 12px; font-size: 14px; font-weight: 600; z-index: 110; box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4); display: flex; align-items: center; gap: 6px; letter-spacing: 0.3px; }
    .variant-pending-badge { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; padding: 6px 10px; border-radius: 8px; font-size: 11px; font-weight: 600; display: inline-flex; align-items: center; gap: 4px; box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3); }
    .main-image { width: 100%; max-width: 300px; border-radius: 0; background: #fafafa; position: relative; }
    .main-image.clickable { cursor: pointer; transition: opacity 0.2s ease; }
    .main-image.clickable:hover { opacity: 0.9; }
    .delete-icon { width: 32px; height: 32px; border-radius: 50%; background: #dc3545; color: #fff; border: 2px solid #dc3545; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; line-height: 1; padding: 0; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3); z-index: 130; }
    .delete-icon:hover { background: #c82333; border-color: #c82333; transform: scale(1.1); box-shadow: 0 4px 8px rgba(220, 53, 69, 0.5); }
    .form-container { position: relative;  }
    .ai-fill-button { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; display: inline-flex; align-items: center; gap: 8px; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3); margin-bottom: 16px; white-space: nowrap; overflow: hidden; position: relative; }
    .ai-fill-button:hover { transform: translateY(-1px); box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4); }
    .ai-fill-button:active { transform: translateY(0); }
    .ai-fill-button.pending { opacity: 0.7; cursor: wait; }
    .ai-fill-button.pending::after { content: ' ⏳'; }
    .ai-fill-button .star-icon { font-size: 16px; flex-shrink: 0; }
    .ai-fill-button .short-text { display: inline-block; }
    .ai-fill-button .full-text { display: inline-block; max-width: 0; opacity: 0; overflow: hidden; transition: max-width 0.3s ease, opacity 0.3s ease; }
    .ai-fill-button:hover .short-text { display: none; }
    .ai-fill-button:hover .full-text { max-width: 300px; opacity: 1; }
    @media (hover: none) {
      .ai-fill-button .short-text { display: none; }
      .ai-fill-button .full-text { max-width: 300px; opacity: 1; }
    }
    .main-image-wrapper .segmented-button { display: flex; width: calc(100% - 24px); border: 1px solid #ccc; border-radius: 6px; overflow: hidden; background: #fff; position: absolute; bottom: 12px; left: 12px; right: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.25); z-index: 50; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; }
    .main-image-wrapper.show-segmented-button:hover .segmented-button { opacity: 1; visibility: visible; }
    @media (hover: none) {
      .main-image-wrapper.show-segmented-button .segmented-button { opacity: 1; visibility: visible; }
    }
    .image-controls { position: absolute; top: 20px; right: 20px; display: flex; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 12px; overflow: hidden; background: #28a745; box-shadow: 0 2px 8px rgba(0,0,0,0.25); z-index: 60; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; }
    .main-image-wrapper.show-segmented-button:hover .image-controls { opacity: 1; visibility: visible; }
    @media (hover: none) {
      .main-image-wrapper.show-segmented-button .image-controls { opacity: 1; visibility: visible; }
    }
    .image-control-btn { background: #28a745; color: #fff; padding: 8px 16px; font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; border: none; border-right: 1px solid rgba(255, 255, 255, 0.3); min-width: 40px; height: 32px; }
    .image-control-btn:last-child { border-right: none; }
    .image-control-btn:hover { background: #218838; }
    .image-control-btn:active { background: #1e7e34; }
    .image-control-btn.rotate { font-size: 16px; }
    .image-control-btn.open-original { font-size: 14px; }
    .image-control-btn.open-final { font-size: 14px; }
    .segmented-button-section { flex: 1; padding: 10px 12px; text-align: center; border-right: 1px solid #ccc; cursor: pointer; transition: all 0.2s ease; font-size: 13px; background: #fff; color: #000; }
    .segmented-button-section:last-child { border-right: none; }
    .segmented-button-section:hover { background: #f5f5f5; }
    .segmented-button-section:active { background: #e8e8e8; }
    .segmented-button-section.loading { opacity: 0.6; cursor: wait; pointer-events: none; }
    .segmented-button-section.ai-style { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; font-weight: 600; border-right-color: rgba(255, 255, 255, 0.3); }
    .segmented-button-section.ai-style:hover { background: linear-gradient(135deg, #5568d3 0%, #653a8f 100%); }
    .segmented-button-section.ai-style .star-icon { font-size: 14px; margin-right: 4px; display: inline-block; }
    .selectable-variants-title { font-size: 12px; color: #ffffff !important; margin-bottom: 8px; font-weight: 600; padding: 6px 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 4px; display: inline-flex; align-items: center; gap: 6px; }
    .selectable-variants-title .star-icon { font-size: 14px; color: #ffffff; }
    .selectable-variant-thumb { width: 60px; height: 60px; object-fit: cover; border-radius: 4px; background: #fafafa; cursor: pointer; border: 2px solid #667eea; transition: all 0.2s; }
    .selectable-variant-thumb:hover { border-color: #764ba2; transform: scale(1.05); box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4); }
    
    /* Responsive design */
    @media (max-width: 1024px) {
      body { margin: 12px; }
      .rowItem { grid-template-columns: 1fr; gap: 16px; }
      .main-image { max-width: 100%; }
      .btns { width: 100%; flex-direction: column; }
      .btns button { width: 100%; }
      .upload-area { padding: 24px 16px; }
      .toolbar { flex-direction: column; align-items: stretch; }
      .toolbar button { width: 100%; }
      /* Make upload sections stack vertically on smaller screens */
      .upload-sections { grid-template-columns: 1fr !important; }
    }
    
    @media (max-width: 768px) {
      body { margin: 8px; }
      h1 { font-size: 18px; }
      h2 { font-size: 14px; }
      .rowItem { padding: 12px; }
      .live-badge, .draft-badge { font-size: 10px; padding: 3px 8px; }
    }
    .variant-thumbs { display: flex; flex-wrap: nowrap; gap: 8px; margin-top: 12px; overflow-x: auto; padding-bottom: 4px; }
    .variant-thumb-wrapper { position: relative; flex-shrink: 0; }
    .variant-thumb { width: 80px; height: 80px; object-fit: cover; border-radius: 6px; background: #fafafa; cursor: pointer; border: 2px solid transparent; display: block; }
    .variant-thumb:hover { border-color: #888; }
    .variant-thumb.active { border-color: #666; }
    .variant-thumb-delete { position: absolute; top: 4px; right: 4px; width: 18px; height: 18px; border-radius: 50%; background: #dc3545; color: #fff; border: 1px solid #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; line-height: 1; padding: 0; z-index: 10; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    .variant-thumb-delete:hover { background: #c82333; }
    .selectable-variants { margin-top: 16px; padding-top: 16px; border-top: 1px solid #eee; display: none; }
    .selectable-variants.visible { display: block; }
    .selectable-variants-grid { display: flex; flex-wrap: wrap; gap: 6px; }
    .selectable-variant-thumb:active { transform: scale(0.95); }
    .add-variant-btn { width: 80px; height: 80px; border: 2px dashed #ccc; border-radius: 6px; background: #fafafa; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 24px; color: #999; transition: all 0.2s; flex-shrink: 0; }
    .add-variant-btn:hover { border-color: #888; color: #666; background: #f0f0f0; }
    .thumb { width: 100%; aspect-ratio: 1 / 1; object-fit: cover; border-radius: 6px; background: #fafafa; }
    .row { display: flex; align-items: center; gap: 8px; }
    button { appearance: none; border: 1px solid #ccc; background: #fff; padding: 8px 12px; border-radius: 6px; cursor: pointer; }
    button.primary { background: #666; color: #fff; border-color: #666; }
    button.primary:hover { background: #555; border-color: #555; }
    .muted { color: #666; font-size: 12px; }
    .toolbar { display: flex; gap: 8px; align-items: center; justify-content: space-between; margin-top: 8px; }
    .hidden { display: none; }
    .flash { border: 1px solid #f2c6c6; background: #fff5f5; color: #8a1f1f; padding: 12px; border-radius: 8px; margin-bottom: 16px; }
    .flash.success { border-color: #bfe1c7; background: #f6fffa; color: #1f6b3a; }
    .field { display: flex; flex-direction: column; gap: 4px; margin-bottom: 8px; }
    .field label { font-size: 12px; color: #555; }
    .field input, .field textarea { width: 100%; padding: 6px 8px; border: 1px solid #ccc; border-radius: 6px; font: inherit; background: #fff; color: #000; }
    .field input:disabled, .field textarea:disabled { background: #f5f5f5; color: #999; cursor: not-allowed; opacity: 0.7; }
    .btns { display: flex; flex-wrap: wrap; gap: 8px; }
    .toast-container { position: fixed; top: 20px; right: 20px; z-index: 10000; display: flex; flex-direction: column; gap: 8px; }
    .toast { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 12px 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 300px; max-width: 400px; animation: toastSlideIn 0.3s ease-out; }
    .toast.success { border-color: #28a745; background: #f6fffa; color: #1f6b3a; }
    .toast.error { border-color: #dc3545; background: #fff5f5; color: #8a1f1f; }
    .toast.info { border-color: #888; background: #f5f5f5; color: #333; }
    @keyframes toastSlideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes toastSlideOut {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
    .toast.hiding { animation: toastSlideOut 0.3s ease-in forwards; }
  </style>
  <link rel="stylesheet" href="common.css">
  <script>
    // Set admin flag in localStorage when admin page loads successfully
    if (typeof Storage !== 'undefined') {
      localStorage.setItem('admin', 'true');
    }
    
    let availableVariants = [];

    async function fetchVariants() {
      try {
        const res = await fetch('variants.php?action=list');
        if (!res.ok) return [];
        const data = await res.json();
        return data.ok ? (data.variants || []) : [];
      } catch (error) {
        console.error('Error fetching variants:', error);
        return [];
      }
    }

    async function fetchImages() {
      const res = await fetch('list_images.php');
      if (!res.ok) return { images: [] };
      return res.json();
    }

    // Auto-save debounce timers for each painting
    const autoSaveTimers = new Map();
    
    function setupAutoSave(imageBaseName, imageOriginalName) {
      const row = document.getElementById(`painting-${imageBaseName}`);
      if (!row) return;
      
      const indicator = document.getElementById(`save-indicator-${imageBaseName}`);
      
      // Get all form fields
      const fields = [
        row.querySelector('input[name="title"]'),
        row.querySelector('textarea[name="description"]'),
        row.querySelector('input[name="width"]'),
        row.querySelector('input[name="height"]'),
        row.querySelector('input[name="tags"]'),
        row.querySelector('input[name="date"]'),
        row.querySelector('input[name="sold"]'),
        row.querySelector('select[name="frame_type"]')
      ].filter(f => f !== null);
      
      // Function to trigger auto-save with specific field
      const triggerAutoSave = (changedField) => {
        // Clear existing timer
        if (autoSaveTimers.has(imageBaseName)) {
          clearTimeout(autoSaveTimers.get(imageBaseName));
        }
        
        // Show "Wird gespeichert..." indicator
        if (indicator) {
          indicator.textContent = 'Wird gespeichert...';
          indicator.style.color = '#666';
          indicator.style.opacity = '1';
        }
        
        // Set new timer (1.5 second delay)
        const timer = setTimeout(async () => {
          try {
            await saveMetaAuto(imageOriginalName, row, indicator, changedField);
          } catch (error) {
            console.error('Auto-save error:', error);
            if (indicator) {
              indicator.textContent = 'Fehler beim Speichern';
              indicator.style.color = '#dc3545';
              indicator.style.opacity = '1';
              setTimeout(() => {
                if (indicator) indicator.style.opacity = '0';
              }, 3000);
            }
          }
          autoSaveTimers.delete(imageBaseName);
        }, 1500);
        
        autoSaveTimers.set(imageBaseName, timer);
      };
      
      // Attach event listeners to all fields
      fields.forEach(field => {
        // Update URL immediately when field changes
        const updateURL = () => {
          updatePaintingURL(imageBaseName);
        };
        
        // Focus event - update URL when clicking/focusing on input
        field.addEventListener('focus', updateURL);
        
        // Input/change events - pass the field that changed
        field.addEventListener('input', () => {
          updateURL();
          triggerAutoSave(field);
        });
        field.addEventListener('change', () => {
          updateURL();
          triggerAutoSave(field);
        });
        
        // Paste event (for text fields)
        if (field.tagName === 'INPUT' || field.tagName === 'TEXTAREA') {
          field.addEventListener('paste', () => {
            // Small delay to let paste complete
            setTimeout(() => {
              updateURL();
              triggerAutoSave(field);
            }, 100);
          });
        }
      });
      
      // Helper function to check if target is an interactive element
      const isInteractiveElement = (target) => {
        return target.closest('button, input, textarea, a, img.clickable, .variant-thumb, .selectable-variant-thumb, .segmented-button-section, .variant-thumb-delete, .delete-icon, .ai-fill-button, .live-badge, .draft-badge, .add-variant-btn, .selectable-variants-title, label, .field');
      };
      
      // Add click listener to the entire row to update URL when clicking background areas
      row.addEventListener('click', (e) => {
        // Update URL when clicking on background areas (not on interactive elements)
        // This includes clicking on the image container background, form container background, etc.
        if (!isInteractiveElement(e.target)) {
          updatePaintingURL(imageBaseName);
        }
      });
    }

    /**
     * Convert image URL to thumbnail URL by inserting _thumb before extension
     * Example: images/painting_final.jpg -> images/painting_final_thumb.jpg
     */
    function getThumbnailUrl(imageUrl) {
      if (!imageUrl) return imageUrl;
      // Match the last dot before the extension
      return imageUrl.replace(/\.(jpg|jpeg|png|gif|webp)$/i, '_thumb.$1');
    }

    // Helper function to extract AI-generated corners from ai_corners data
    function extractAICorners(meta) {
      const aiCorners = meta.ai_corners || {};
      if (!aiCorners.replicate_response) {
        return null;
      }
      
      const replicateResponse = aiCorners.replicate_response;
      if (!replicateResponse.output || !Array.isArray(replicateResponse.output)) {
        return null;
      }
      
      // Join output array (may be split across multiple elements)
      const outputText = replicateResponse.output.join('');
      
      // Try to extract JSON from code blocks (```json ... ```)
      let jsonStr = null;
      if (outputText.includes('```json') || outputText.includes('```')) {
        const match = outputText.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
        if (match) {
          jsonStr = match[1];
        }
      }
      
      // If no code block, try to find JSON object
      if (!jsonStr) {
        const jsonStart = outputText.indexOf('{');
        if (jsonStart !== -1) {
          // Find matching closing brace
          let braceCount = 0;
          let jsonEnd = jsonStart;
          let inString = false;
          let escapeNext = false;
          
          for (let i = jsonStart; i < outputText.length; i++) {
            const char = outputText[i];
            
            if (escapeNext) {
              escapeNext = false;
              continue;
            }
            
            if (char === '\\') {
              escapeNext = true;
              continue;
            }
            
            if (char === '"' && !escapeNext) {
              inString = !inString;
              continue;
            }
            
            if (!inString) {
              if (char === '{') {
                braceCount++;
              } else if (char === '}') {
                braceCount--;
                if (braceCount === 0) {
                  jsonEnd = i + 1;
                  break;
                }
              }
            }
          }
          
          if (braceCount === 0) {
            jsonStr = outputText.substring(jsonStart, jsonEnd);
          }
        }
      }
      
      if (!jsonStr) {
        return null;
      }
      
      // Clean up JSON string
      jsonStr = jsonStr.replace(/(\d+)\s+\.\s*(\d+)/g, '$1.$2');
      jsonStr = jsonStr.replace(/(\d+)\s*\.\s+(\d+)/g, '$1.$2');
      jsonStr = jsonStr.replace(/"\s+"([^"]+)"/g, '"$1"');
      
      try {
        const cornersData = JSON.parse(jsonStr);
        if (cornersData && cornersData.corners && Array.isArray(cornersData.corners) && cornersData.corners.length === 4) {
          return {
            corners: cornersData.corners,
            offset_percent: aiCorners.offset_percent || 1.0,
            timestamp: aiCorners.timestamp,
            status: aiCorners.prediction_status
          };
        }
      } catch (e) {
        console.error('Failed to parse AI corners JSON:', e);
      }
      
      return null;
    }

    function renderImageRow(g) {
      const row = document.createElement('div');
      row.className = g.in_gallery ? 'rowItem live' : 'rowItem';
      row.id = `painting-${g.base}`;
      const meta = g.meta || {};
      const originalVariant = (g.variants.find(v => v.variant === 'original') || g.variants[0]);
      
      // Extract AI-generated corners
      const aiCornersData = extractAICorners(meta);
      
      // Find final image
      const finalVariant = g.variants.find(v => v.variant === 'final');
      // Find variant images (those that start with "variant_")
      const imageVariants = g.variants.filter(v => v.variant && v.variant.startsWith('variant_'));
      // Extract variant names that are already added (remove "variant_" prefix)
      const addedVariantNames = new Set(
        imageVariants.map(v => {
          // Extract variant name: "variant_arbeitszimmer" -> "arbeitszimmer"
          return v.variant.replace(/^variant_/, '');
        })
      );
      // Filter available variants to exclude already added ones
      const selectableVariants = availableVariants.filter(v => {
        // Extract variant name from filename: "arbeitszimmer.jpg" -> "arbeitszimmer"
        const variantName = v.name.replace(/\.(jpg|jpeg)$/i, '');
        return !addedVariantNames.has(variantName);
      });
      // Combine: final first, then variants
      const allVariants = [];
      if (finalVariant) {
        allVariants.push(finalVariant);
      }
      allVariants.push(...imageVariants);
      
      // Add cache-busting timestamp to image URLs to ensure fresh load
      const cacheBuster = '?t=' + Date.now();
      const imageClickable = g.in_gallery && g.gallery_filename;
      // Create click handler that includes variant index (1-based: final=1, first variant=2, etc.)
      const imageClickHandler = imageClickable ? `onclick="handleImageClick('${escapeHtml(g.base)}', '${encodeURIComponent(g.gallery_filename)}')"` : '';
      const imageClass = imageClickable ? 'main-image clickable' : 'main-image';
      const badgeClickHandler = `handleBadgeClick('${escapeHtml(originalVariant.name)}', ${g.in_gallery ? 'true' : 'false'})`;
      const showSegmentedButton = finalVariant ? 'show-segmented-button' : '';
      const frameType = meta.frame_type || 'white';
      
      // Check AI generation status (corners and form separately)
      const aiCorners = meta.ai_corners || {};
      const aiFillForm = meta.ai_fill_form || {};
      const aiPaintingVariants = meta.ai_painting_variants || {};
      const cornersStatus = aiCorners.status || null;
      const formStatus = aiFillForm.status || null;
      // Badge on _final image: 
      // - Always check cornersStatus (corners creates the _final image)
      // - Form status should NOT affect the _final image display
      const hasPendingAIForFinalImage = cornersStatus && ['wanted', 'in_progress'].includes(cornersStatus);
      // General pending AI check (for other UI elements)
      const hasPendingAI = (cornersStatus && ['wanted', 'in_progress'].includes(cornersStatus)) || 
                           (formStatus && ['wanted', 'in_progress'].includes(formStatus));
      
      const aiStatusBadge = hasPendingAI 
        ? `<div class="ai-pending-badge" title="KI-Verarbeitung ausstehend - wird im Hintergrund verarbeitet">
            <span class="text-2xl">⭐</span> KI ausstehend
          </div>`
        : '';
      
      row.innerHTML = `
        <div class="image-container">
          <div class="main-image-wrapper ${showSegmentedButton} pos-relative">
            ${g.in_gallery ? `<div class="live-badge clickable" onclick="event.stopPropagation(); event.preventDefault(); ${badgeClickHandler}" title="Zurück auf Entwurf">Live</div>` : `<div class="draft-badge clickable" onclick="event.stopPropagation(); event.preventDefault(); ${badgeClickHandler}" title="Live schalten">Entwurf</div>`}
            <div class="admin-frame-preview frame-${frameType} pos-relative" id="frame-preview-${g.base}">
              ${hasPendingAIForFinalImage ? `<div class="ai-pending-overlay" title="${formStatus && ['wanted', 'in_progress'].includes(formStatus) ? 'KI Formular ausfüllen ausstehend' : 'KI Ecken-Erkennung ausstehend'} - wird im Hintergrund verarbeitet">
                <div class="ai-pending-badge-content">
                  <span class="text-3xl">⭐</span> KI ausstehend
                </div>
              </div>` : ''}
              ${finalVariant ? `
                <img class="${imageClass} ${hasPendingAIForFinalImage ? 'opacity-30' : ''}" id="main-img-${g.base}" loading="lazy" src="${getThumbnailUrl(finalVariant.url)}${cacheBuster}" alt="${finalVariant.name}" ${imageClickHandler} data-variant="final">
              ` : '<div class="main-image main-image-placeholder">Kein Final-Bild</div>'}
            </div>
            ${finalVariant ? `
            <div class="image-controls">
              <button class="image-control-btn rotate" onclick="event.stopPropagation(); rotateImage('${escapeHtml(finalVariant.name)}', '${escapeHtml(g.base)}', this)" title="Bild um 90° drehen">↻</button>
              <button class="image-control-btn open-original" onclick="event.stopPropagation(); openOriginalImage('${escapeHtml(originalVariant.name)}')" title="Originalbild öffnen">O</button>
              <button class="image-control-btn open-final" onclick="event.stopPropagation(); openFinalImage('${escapeHtml(finalVariant.name)}')" title="Final-Bild öffnen">F</button>
            </div>
            <div class="segmented-button">
              <div class="segmented-button-section" onclick='doAction("${escapeHtml(originalVariant.name)}", "restore", this)'>Originalbild verwenden</div>
              <div class="segmented-button-section ai-style" onclick='doCorners("${escapeHtml(originalVariant.name)}", this)'><span class="star-icon">⭐</span>KI Bild freistellen lassen</div>
              <div class="segmented-button-section" onclick='doManualFree("${escapeHtml(originalVariant.name)}", this)'>Bild von Hand freistellen</div>
            </div>
            ` : ''}
          </div>
          ${allVariants.length > 0 ? `
            <div class="variant-thumbs" id="thumbs-${g.base}">
              ${allVariants.map((v) => {
                // Check if variant is pending (no file yet)
                const isPending = v.pending === true;
                
                // Don't show pending variants as images, show as badge that fills the area
                if (isPending) {
                  // Extract variant name from variant type (e.g., "variant_kommode" -> "kommode")
                  const variantName = v.variant ? v.variant.replace(/^variant_/, '') : v.name.replace(/^.*_variant_/, '').replace(/\.jpg$/i, '');
                  return `
                  <div class="variant-thumb-wrapper pos-relative">
                    <div class="variant-pending-wrapper pos-relative">
                      <div class="variant-pending-content">
                        <span class="text-2xl text-white">⭐</span>
                        <span class="text-sm text-white font-semibold text-center leading-tight">${variantName}</span>
                      </div>
                    </div>
                    ${v.variant && v.variant.startsWith('variant_') ? `
                      <button class="variant-thumb-delete" 
                              onclick="event.stopPropagation(); deleteImageVariant('${escapeHtml(v.name)}', '${escapeHtml(g.base)}', this)"
                              title="Löschen">×</button>
                    ` : ''}
                  </div>
                `;
                }
                
                // Generate thumbnail URL implicitly from image URL
                const thumbUrl = getThumbnailUrl(v.url);
                return `
                <div class="variant-thumb-wrapper">
                  <img class="variant-thumb ${v.variant === 'final' ? 'active' : ''}" 
                       loading="lazy" 
                       src="${thumbUrl}${cacheBuster}" 
                       alt="${v.name}"
                       data-variant="${v.variant || ''}"
                       onclick="selectVariantByValue('${escapeHtml(g.base)}', '${v.variant || ''}', '${v.url}')"
                       title="${v.name}">
                  ${v.variant && v.variant.startsWith('variant_') ? `
                    <button class="variant-thumb-delete" 
                            onclick="event.stopPropagation(); deleteImageVariant('${escapeHtml(v.name)}', '${escapeHtml(g.base)}', this)"
                            title="Löschen">×</button>
                  ` : ''}
                </div>
              `;
              }).join('')}
              <div class="add-variant-btn" onclick="toggleVariants('${escapeHtml(g.base)}')" title="KI Variante hinzufügen">+</div>
            </div>
          ` : `
            <div class="variant-thumbs" id="thumbs-${g.base}">
              <div class="add-variant-btn" onclick="toggleVariants('${escapeHtml(g.base)}')" title="KI Variante hinzufügen">+</div>
            </div>
          `}
          <div class="selectable-variants" id="selectable-variants-${g.base}">
            <div class="selectable-variants-title"><span class="star-icon">⭐</span>KI Varianten</div>
            <div class="selectable-variants-grid" id="variants-${g.base}">
              ${selectableVariants.length > 0 ? selectableVariants.map(v => `
                <img class="selectable-variant-thumb" 
                     src="${escapeHtml(v.url)}" 
                     alt="${escapeHtml(v.name)}"
                     title="${escapeHtml(v.name)}"
                     onclick="copyVariantToImage('${escapeHtml(v.name)}', '${escapeHtml(g.base)}', ${g.in_gallery ? 'true' : 'false'}, '${escapeHtml(originalVariant.name)}', this)">
              `).join('') : '<span class="muted muted-text-sm">Keine Varianten verfügbar</span>'}
            </div>
          </div>
        </div>
        <div class="form-container form-container-padded">
          <button class="delete-icon delete-icon-positioned" onclick="event.stopPropagation(); deleteCompletely('${escapeHtml(originalVariant.name)}', this)" title="Vollständig löschen">×</button>
          <div class="pos-relative">
            ${formStatus && ['wanted', 'in_progress'].includes(formStatus) ? `<div class="ai-pending-overlay bg-white-95" title="KI Formular ausfüllen ausstehend - wird im Hintergrund verarbeitet">
              <div class="ai-pending-badge-content-sm">
                <span class="text-3xl">⭐</span> 
                <span>KI Formular ausfüllen ausstehend</span>
              </div>
            </div>` : ''}
            <div class="${formStatus && ['wanted', 'in_progress'].includes(formStatus) ? 'form-disabled' : ''}">
              <div class="flex gap-8 mb-16 items-center">
                <button type="button" class="ai-fill-button ${formStatus && ['wanted', 'in_progress'].includes(formStatus) ? 'pending' : ''}" 
                        onclick='fillFormWithAI("${escapeHtml(originalVariant.name)}", this)' 
                        title="${formStatus && ['wanted', 'in_progress'].includes(formStatus) ? 'KI Formular ausfüllen ausstehend - wird im Hintergrund verarbeitet' : 'KI Formular ausfüllen lassen'}"
                        ${formStatus && ['wanted', 'in_progress'].includes(formStatus) ? 'disabled' : ''}>
                  <span class="star-icon">⭐</span>
                  <span class="short-text">${formStatus && ['wanted', 'in_progress'].includes(formStatus) ? 'KI ausstehend' : 'KI'}</span>
                  <span class="full-text">${formStatus && ['wanted', 'in_progress'].includes(formStatus) ? 'Formular ausfüllen ausstehend' : 'Formular ausfüllen lassen'}</span>
                </button>
              </div>
              <div class="field">
                <label>Titel</label>
                <input type="text" name="title" value="${escapeHtml(meta.title || '')}" data-ai-field="true">
              </div>
              <div class="field">
                <label>Beschreibung</label>
                <textarea name="description" rows="3" data-ai-field="true">${escapeHtml(meta.description || '')}</textarea>
              </div>
              <div class="field-grid">
                <div class="field field-max-w-100">
                  <label>Breite (cm)</label>
                  <input type="text" name="width" value="${escapeHtml(meta.width || '')}" data-ai-field="true">
                </div>
                <div class="field field-max-w-100">
                  <label>Höhe (cm)</label>
                  <input type="text" name="height" value="${escapeHtml(meta.height || '')}" data-ai-field="true">
                </div>
                <div class="field field-max-w-120">
                  <label>Datum (dd.mm.yyyy)</label>
                  <input type="text" name="date" value="${escapeHtml(meta.date || '')}" data-ai-field="true">
                </div>
              </div>
              <div class="field">
                <label>Tags</label>
                <input type="text" name="tags" value="${escapeHtml(meta.tags || '')}" data-ai-field="true">
              </div>
              <div class="field">
                <label class="checkbox-field">
                  <input type="checkbox" name="sold" ${meta.sold ? 'checked' : ''} class="checkbox-input">
                  Verkauft
                </label>
              </div>
              <div class="field">
                <label>Rahmen</label>
                <select name="frame_type" id="frame-type-${g.base}" onchange="updateFramePreview('${g.base}', this.value)" class="select-field">
                  <option value="white" ${frameType === 'white' ? 'selected' : ''}>Weiß</option>
                  <option value="black" ${frameType === 'black' ? 'selected' : ''}>Schwarz</option>
                  <option value="wood" ${frameType === 'wood' ? 'selected' : ''}>Holz (Mittel)</option>
                  <option value="oak" ${frameType === 'oak' ? 'selected' : ''}>Eiche (Hell)</option>
                  <option value="walnut" ${frameType === 'walnut' ? 'selected' : ''}>Walnuss (Dunkel)</option>
                  <option value="gold" ${frameType === 'gold' ? 'selected' : ''}>Gold (Einfach)</option>
                  <option value="ornate-gold" ${frameType === 'ornate-gold' ? 'selected' : ''}>Gold (Ornamental)</option>
                  <option value="silver" ${frameType === 'silver' ? 'selected' : ''}>Silber</option>
                  <option value="natural" ${frameType === 'natural' ? 'selected' : ''}>Natur (Beige)</option>
                  <option value="none" ${frameType === 'none' ? 'selected' : ''}>Kein Rahmen</option>
                </select>
                
              </div>
              <div class="${formStatus && ['wanted', 'in_progress'].includes(formStatus) ? 'hidden' : ''}">
                <button type="button" class="primary button-primary" onclick='saveMeta("${escapeHtml(originalVariant.name)}", this)'>
                  Speichern
                </button>
              </div>
            </div>
          </div>
          <div class="field field-divider">
            <button type="button" id="toggle-details-${g.base}" class="details-toggle" onclick="const content = document.getElementById('details-content-${g.base}'); const btn = this; content.classList.toggle('hidden'); btn.textContent = content.classList.contains('hidden') ? '▶ Weitere Informationen' : '▼ Weitere Informationen';">
              ▶ Weitere Informationen
            </button>
            <div id="details-content-${g.base}" class="details-content hidden">
              <div class="details-section">
                <label class="details-label">KI Status:</label>
                <div class="details-grid">
                  <div>
                    <label class="details-label-sm">KI Corners Status:</label>
                    <select id="ai-corners-status-${g.base}" onchange="updateAIStatus('${escapeHtml(originalVariant.name)}', 'ai_corners_status', this.value, '${g.base}')" class="select-field-sm">
                      <option value="" ${!cornersStatus ? 'selected' : ''}>-</option>
                      <option value="wanted" ${cornersStatus === 'wanted' ? 'selected' : ''}>wanted</option>
                      <option value="in_progress" ${cornersStatus === 'in_progress' ? 'selected' : ''}>in_progress</option>
                      <option value="completed" ${cornersStatus === 'completed' ? 'selected' : ''}>completed</option>
                      <option value="error" ${cornersStatus === 'error' ? 'selected' : ''}>error</option>
                    </select>
                    ${aiCorners.started_at ? `<small class="details-text-small">Gestartet: ${new Date(aiCorners.started_at).toLocaleString('de-DE')}</small>` : ''}
                    ${aiCorners.completed_at ? `<small class="details-text-small">Abgeschlossen: ${new Date(aiCorners.completed_at).toLocaleString('de-DE')}</small>` : ''}
                  </div>
                  <div>
                    <label class="details-label-sm">KI Form Status:</label>
                    <select id="ai-form-status-${g.base}" onchange="updateAIStatus('${escapeHtml(originalVariant.name)}', 'ai_form_status', this.value, '${g.base}')" class="select-field-sm">
                      <option value="" ${!formStatus ? 'selected' : ''}>-</option>
                      <option value="wanted" ${formStatus === 'wanted' ? 'selected' : ''}>wanted</option>
                      <option value="in_progress" ${formStatus === 'in_progress' ? 'selected' : ''}>in_progress</option>
                      <option value="completed" ${formStatus === 'completed' ? 'selected' : ''}>completed</option>
                      <option value="error" ${formStatus === 'error' ? 'selected' : ''}>error</option>
                    </select>
                    ${aiFillForm.started_at ? `<small class="details-text-small">Gestartet: ${new Date(aiFillForm.started_at).toLocaleString('de-DE')}</small>` : ''}
                    ${aiFillForm.completed_at ? `<small class="details-text-small">Abgeschlossen: ${new Date(aiFillForm.completed_at).toLocaleString('de-DE')}</small>` : ''}
                  </div>
                </div>
                ${aiPaintingVariants.variants && Object.keys(aiPaintingVariants.variants).length > 0 ? `
                <div class="details-section-divider">
                  <label class="details-section-label">KI Painting Variants:</label>
                  <div class="details-variants-list">
                    ${Object.entries(aiPaintingVariants.variants).map(([variantKey, variant]) => {
                      const variantStatus = variant.status || null;
                      const predictionStatus = variant.prediction_status || null;
                      return `
                        <div class="details-variant-item">
                          <div class="details-variant-header">
                            <label class="details-variant-label">${escapeHtml(variant.variant_name || variantKey)}:</label>
                            <select id="ai-painting-variant-status-${g.base}-${variantKey}" 
                                    onchange="updateAIPaintingVariantStatus('${escapeHtml(originalVariant.name)}', '${variantKey}', this.value, '${g.base}')" 
                                    class="select-field-sm">
                              <option value="" ${!variantStatus ? 'selected' : ''}>-</option>
                              <option value="wanted" ${variantStatus === 'wanted' ? 'selected' : ''}>wanted</option>
                              <option value="in_progress" ${variantStatus === 'in_progress' ? 'selected' : ''}>in_progress</option>
                              <option value="completed" ${variantStatus === 'completed' ? 'selected' : ''}>completed</option>
                              <option value="error" ${variantStatus === 'error' ? 'selected' : ''}>error</option>
                            </select>
                          </div>
                          ${predictionStatus ? `<small class="details-text-small-mb">Prediction Status: ${escapeHtml(predictionStatus)}</small>` : ''}
                          ${variant.started_at ? `<small class="details-text-small">Gestartet: ${new Date(variant.started_at).toLocaleString('de-DE')}</small>` : ''}
                          ${variant.completed_at ? `<small class="details-text-small">Abgeschlossen: ${new Date(variant.completed_at).toLocaleString('de-DE')}</small>` : ''}
                          ${variant.prediction_id ? `<small class="details-text-small">Prediction ID: ${escapeHtml(variant.prediction_id)}</small>` : ''}
                        </div>
                      `;
                    }).join('')}
                  </div>
                </div>
                ` : ''}
                <button type="button" onclick="showFullJSON('${escapeHtml(originalVariant.name)}', '${g.base}')" class="button-json">
                  JSON anzeigen
                </button>
              </div>
              ${(meta.manual_corners && Array.isArray(meta.manual_corners) && meta.manual_corners.length === 4) || aiCornersData ? `
              <div class="corners-grid">
                ${meta.manual_corners && Array.isArray(meta.manual_corners) && meta.manual_corners.length === 4 ? `
                <div>
                  <label class="corners-label">Manuelle Ecken-Positionen:</label>
                  <div class="corners-text">
                    ${meta.image_dimensions ? `
                      Oben links: (${meta.manual_corners[0][0]}, ${meta.manual_corners[0][1]}) px = (${(meta.manual_corners[0][0] / meta.image_dimensions.width * 100).toFixed(2)}%, ${(meta.manual_corners[0][1] / meta.image_dimensions.height * 100).toFixed(2)}%)<br>
                      Oben rechts: (${meta.manual_corners[1][0]}, ${meta.manual_corners[1][1]}) px = (${(meta.manual_corners[1][0] / meta.image_dimensions.width * 100).toFixed(2)}%, ${(meta.manual_corners[1][1] / meta.image_dimensions.height * 100).toFixed(2)}%)<br>
                      Unten rechts: (${meta.manual_corners[2][0]}, ${meta.manual_corners[2][1]}) px = (${(meta.manual_corners[2][0] / meta.image_dimensions.width * 100).toFixed(2)}%, ${(meta.manual_corners[2][1] / meta.image_dimensions.height * 100).toFixed(2)}%)<br>
                      Unten links: (${meta.manual_corners[3][0]}, ${meta.manual_corners[3][1]}) px = (${(meta.manual_corners[3][0] / meta.image_dimensions.width * 100).toFixed(2)}%, ${(meta.manual_corners[3][1] / meta.image_dimensions.height * 100).toFixed(2)}%)
                    ` : `
                      Oben links: (${meta.manual_corners[0][0]}, ${meta.manual_corners[0][1]})<br>
                      Oben rechts: (${meta.manual_corners[1][0]}, ${meta.manual_corners[1][1]})<br>
                      Unten rechts: (${meta.manual_corners[2][0]}, ${meta.manual_corners[2][1]})<br>
                      Unten links: (${meta.manual_corners[3][0]}, ${meta.manual_corners[3][1]})
                    `}
                  </div>
                </div>
                ` : ''}
                ${aiCornersData ? `
                <div>
                  <label class="corners-label">
                    <span class="star-icon star-icon-sm">⭐</span> KI-generierte Ecken:
                  </label>
                  <div class="corners-text">
                    ${meta.image_dimensions ? `
                      <div class="corners-divider">
                        <strong class="corners-label-strong">Raw (vor Offset):</strong><br>
                        Oben links: ${aiCornersData.corners[0].x.toFixed(2)}%, ${aiCornersData.corners[0].y.toFixed(2)}% = (${Math.round(aiCornersData.corners[0].x / 100 * meta.image_dimensions.width)}, ${Math.round(aiCornersData.corners[0].y / 100 * meta.image_dimensions.height)}) px<br>
                        Oben rechts: ${aiCornersData.corners[1].x.toFixed(2)}%, ${aiCornersData.corners[1].y.toFixed(2)}% = (${Math.round(aiCornersData.corners[1].x / 100 * meta.image_dimensions.width)}, ${Math.round(aiCornersData.corners[1].y / 100 * meta.image_dimensions.height)}) px<br>
                        Unten rechts: ${aiCornersData.corners[2].x.toFixed(2)}%, ${aiCornersData.corners[2].y.toFixed(2)}% = (${Math.round(aiCornersData.corners[2].x / 100 * meta.image_dimensions.width)}, ${Math.round(aiCornersData.corners[2].y / 100 * meta.image_dimensions.height)}) px<br>
                        Unten links: ${aiCornersData.corners[3].x.toFixed(2)}%, ${aiCornersData.corners[3].y.toFixed(2)}% = (${Math.round(aiCornersData.corners[3].x / 100 * meta.image_dimensions.width)}, ${Math.round(aiCornersData.corners[3].y / 100 * meta.image_dimensions.height)}) px
                      </div>
                      ${aiCorners && aiCorners.corners_used && Array.isArray(aiCorners.corners_used) && aiCorners.corners_used.length === 4 ? `
                      <div>
                        <strong class="corners-label-strong">Verwendet (nach Offset ${aiCornersData.offset_percent}%):</strong><br>
                        Oben links: (${aiCorners.corners_used[0][0]}, ${aiCorners.corners_used[0][1]}) px = (${(aiCorners.corners_used[0][0] / meta.image_dimensions.width * 100).toFixed(2)}%, ${(aiCorners.corners_used[0][1] / meta.image_dimensions.height * 100).toFixed(2)}%)<br>
                        Oben rechts: (${aiCorners.corners_used[1][0]}, ${aiCorners.corners_used[1][1]}) px = (${(aiCorners.corners_used[1][0] / meta.image_dimensions.width * 100).toFixed(2)}%, ${(aiCorners.corners_used[1][1] / meta.image_dimensions.height * 100).toFixed(2)}%)<br>
                        Unten rechts: (${aiCorners.corners_used[2][0]}, ${aiCorners.corners_used[2][1]}) px = (${(aiCorners.corners_used[2][0] / meta.image_dimensions.width * 100).toFixed(2)}%, ${(aiCorners.corners_used[2][1] / meta.image_dimensions.height * 100).toFixed(2)}%)<br>
                        Unten links: (${aiCorners.corners_used[3][0]}, ${aiCorners.corners_used[3][1]}) px = (${(aiCorners.corners_used[3][0] / meta.image_dimensions.width * 100).toFixed(2)}%, ${(aiCorners.corners_used[3][1] / meta.image_dimensions.height * 100).toFixed(2)}%)
                      </div>
                      ` : ''}
                    ` : `
                      Oben links: x=${aiCornersData.corners[0].x.toFixed(2)}%, y=${aiCornersData.corners[0].y.toFixed(2)}%<br>
                      Oben rechts: x=${aiCornersData.corners[1].x.toFixed(2)}%, y=${aiCornersData.corners[1].y.toFixed(2)}%<br>
                      Unten rechts: x=${aiCornersData.corners[2].x.toFixed(2)}%, y=${aiCornersData.corners[2].y.toFixed(2)}%<br>
                      Unten links: x=${aiCornersData.corners[3].x.toFixed(2)}%, y=${aiCornersData.corners[3].y.toFixed(2)}%
                    `}
                    <span class="corners-meta">
                      Offset: ${aiCornersData.offset_percent}% | Status: ${aiCornersData.status || 'unknown'}
                      ${aiCornersData.timestamp ? ' | ' + new Date(aiCornersData.timestamp).toLocaleString('de-DE') : ''}
                    </span>
                  </div>
                </div>
                ` : ''}
              </div>
              ` : ''}
            </div>
          </div>
        </div>
      `;
      
      // Store allVariants array on the row for later access (including URLs)
      row.dataset.variants = JSON.stringify(allVariants.map(v => ({ 
        variant: v.variant || '', 
        name: v.name,
        url: v.url
      })));
      
      // Store painting identifier for URL updates
      row.dataset.paintingBase = g.base;
      row.dataset.paintingGalleryFilename = g.gallery_filename || '';
      row.dataset.paintingInGallery = g.in_gallery ? 'true' : 'false';
      
      // Store form status to detect when form completes
      // formStatus is already declared above, so reuse it
      if (formStatus) {
        row.dataset.formStatus = formStatus;
      }
      
      return row;
    }

    function getVariantIndex(imageBaseName, variantValue) {
      const row = document.getElementById(`painting-${imageBaseName}`);
      if (!row || !row.dataset.variants) return 1; // Default to 1 (final)
      
      try {
        const variants = JSON.parse(row.dataset.variants);
        // Find index of variant (1-based: final=1, first variant=2, etc.)
        const index = variants.findIndex(v => v.variant === variantValue);
        return index >= 0 ? index + 1 : 1; // Return 1-based index, default to 1 if not found
      } catch (e) {
        return 1;
      }
    }

    function updatePaintingURL(imageBaseName) {
      const row = document.getElementById(`painting-${imageBaseName}`);
      if (!row) return;
      
      // Get painting identifier (prefer gallery_filename, fallback to base)
      const galleryFilename = row.dataset.paintingGalleryFilename;
      const base = row.dataset.paintingBase || imageBaseName;
      const paintingId = galleryFilename || base;
      
      // Get current variant
      const mainImg = document.getElementById(`main-img-${imageBaseName}`);
      if (!mainImg) return;
      
      const currentVariant = mainImg.getAttribute('data-variant') || 'final';
      const variantIndex = getVariantIndex(imageBaseName, currentVariant);
      
      // Update URL without reloading
      const newUrl = new URL(window.location);
      newUrl.searchParams.set('painting', paintingId);
      newUrl.searchParams.set('variant', variantIndex.toString());
      
      // Use replaceState to avoid adding to history
      window.history.replaceState({}, '', newUrl);
    }

    function handleImageClick(imageBaseName, galleryFilename) {
      const mainImg = document.getElementById(`main-img-${imageBaseName}`);
      if (!mainImg) return;
      
      const currentVariant = mainImg.getAttribute('data-variant') || 'final';
      const variantIndex = getVariantIndex(imageBaseName, currentVariant);
      
      // Navigate with variant parameter (1-based index)
      const url = `/index.html?painting=${encodeURIComponent(galleryFilename)}&variant=${variantIndex}`;
      window.location.href = url;
    }

    function updateFramePreview(imageBaseName, frameType) {
      const framePreview = document.getElementById(`frame-preview-${imageBaseName}`);
      if (!framePreview) return;
      
      // Remove all frame classes
      framePreview.classList.remove('frame-white', 'frame-wood', 'frame-black', 'frame-gold', 'frame-silver', 'frame-walnut', 'frame-oak', 'frame-ornate-gold', 'frame-natural', 'frame-none');
      // Add the new frame class
      framePreview.classList.add(`frame-${frameType}`);
    }

    function selectVariantByValue(imageBaseName, variantValue, variantUrl) {
      const mainImg = document.getElementById(`main-img-${imageBaseName}`);
      const thumbs = document.getElementById(`thumbs-${imageBaseName}`);
      const wrapper = mainImg ? mainImg.closest('.main-image-wrapper') : null;
      
      if (!mainImg || !thumbs) return;
      
      // Update main image (use thumbnail version)
      const thumbUrl = getThumbnailUrl(variantUrl.split('?')[0]) + '?t=' + Date.now();
      mainImg.src = thumbUrl;
      mainImg.setAttribute('data-variant', variantValue || '');
      
      // Update active state on thumbs
      const thumbElements = thumbs.querySelectorAll('.variant-thumb');
      thumbElements.forEach(thumb => {
        if (thumb.getAttribute('data-variant') === variantValue) {
          thumb.classList.add('active');
        } else {
          thumb.classList.remove('active');
        }
      });
      
      // Update segmented button visibility
      if (wrapper) {
        if (variantValue === 'final') {
          wrapper.classList.add('show-segmented-button');
        } else {
          wrapper.classList.remove('show-segmented-button');
        }
      }
      
      // Update URL
      updatePaintingURL(imageBaseName);
    }

    function selectVariant(imageBaseName, variantIndex) {
      const row = document.getElementById(`painting-${imageBaseName}`);
      if (!row || !row.dataset.variants) return;
      
      try {
        const variants = JSON.parse(row.dataset.variants);
        // variantIndex is 1-based, convert to 0-based
        const index = variantIndex - 1;
        if (index < 0 || index >= variants.length) return;
        
        const variant = variants[index];
        const mainImg = document.getElementById(`main-img-${imageBaseName}`);
        const thumbs = document.getElementById(`thumbs-${imageBaseName}`);
        const wrapper = mainImg ? mainImg.closest('.main-image-wrapper') : null;
        
        if (!mainImg || !thumbs || !variant) return;
        
        // Update main image with the variant URL (use thumbnail version)
        const variantUrl = variant.url.split('?')[0];
        const thumbUrl = getThumbnailUrl(variantUrl) + '?t=' + Date.now();
        mainImg.src = thumbUrl;
        mainImg.setAttribute('data-variant', variant.variant || '');
        
        // Update active state on thumbs
        const thumbElements = thumbs.querySelectorAll('.variant-thumb');
        thumbElements.forEach((thumb, idx) => {
          if (idx === index) {
            thumb.classList.add('active');
          } else {
            thumb.classList.remove('active');
          }
        });
        
        // Update segmented button visibility
        if (wrapper) {
          if (variant.variant === 'final') {
            wrapper.classList.add('show-segmented-button');
          } else {
            wrapper.classList.remove('show-segmented-button');
          }
        }
        
        // Update URL
        updatePaintingURL(imageBaseName);
      } catch (e) {
        console.error('Error selecting variant:', e);
      }
    }

    function renderImages(groups) {
      const container = document.getElementById('images');
      container.innerHTML = '';
      if (!groups.length) {
        container.innerHTML = '<p class="muted">Noch keine Bilder vorhanden.</p>';
        return;
      }

      for (const g of groups) {
        const row = renderImageRow(g);
        container.appendChild(row);
      }
    }

    async function refresh() {
      // Fetch variants first
      availableVariants = await fetchVariants();
      
      const { groups } = await fetchImages();
      renderImages(groups);
      
      // Check for painting parameter in URL and scroll to it
      const urlParams = new URLSearchParams(window.location.search);
      const paintingParam = urlParams.get('painting');
      const variantParam = urlParams.get('variant');
      if (paintingParam) {
        // Try to find by gallery_filename first, then fallback to base
        let targetElement = null;
        let targetBase = null;
        for (const g of groups) {
          if (g.gallery_filename && g.gallery_filename.toLowerCase() === paintingParam.toLowerCase()) {
            targetElement = document.getElementById(`painting-${g.base}`);
            targetBase = g.base;
            break;
          }
          if (g.base.toLowerCase() === paintingParam.toLowerCase()) {
            targetElement = document.getElementById(`painting-${g.base}`);
            targetBase = g.base;
            break;
          }
        }
        if (targetElement) {
          setTimeout(() => {
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
            // Highlight the element briefly
            targetElement.style.transition = 'box-shadow 0.3s ease';
            targetElement.style.boxShadow = '0 0 0 4px rgba(11, 95, 255, 0.5)';
            setTimeout(() => {
              targetElement.style.boxShadow = '';
            }, 2000);
            
            // Select variant if parameter is present
            if (variantParam && targetBase) {
              const variantIndex = parseInt(variantParam, 10);
              if (!isNaN(variantIndex) && variantIndex > 0) {
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                  selectVariant(targetBase, variantIndex);
                }, 200);
              }
            }
          }, 100);
        }
      }
    }

    async function deleteImageVariant(filename, imageBaseName, btn) {
      if (!confirm('Möchten Sie diese Variante wirklich löschen?')) {
        return;
      }

      const prev = btn.textContent;
      btn.disabled = true;
      btn.style.opacity = '0.5';

      try {
        const body = new FormData();
        body.set('filename', filename);

        const res = await fetch('delete_image_variant.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Löschen fehlgeschlagen: ' + msg, 'error');
          return;
        }

        const data = await res.json();
        if (!data.ok) {
          showToast('Löschen fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }

        showToast('Variante erfolgreich gelöscht', 'success');
        refresh();
      } catch (error) {
        showToast('Fehler: ' + error.message, 'error');
      } finally {
        btn.disabled = false;
        btn.style.opacity = '';
      }
    }

    async function copyVariantToImage(variantFilename, imageBaseName, isLive, originalImageName, thumbElement) {
      // Update URL when interacting with variant generation
      updatePaintingURL(imageBaseName);
      
      const prevOpacity = thumbElement.style.opacity;
      thumbElement.style.opacity = '0.5';
      thumbElement.style.cursor = 'wait';
      
      // Extract variant name from filename (remove .jpg extension)
      const variantName = variantFilename.replace(/\.(jpg|jpeg)$/i, '');
      
      try {
        // Add variant to queue (only updates JSON, doesn't create file yet)
        const body = new FormData();
        body.set('image_base_name', imageBaseName);
        body.set('variant_name', variantName);

        const res = await fetch('/admin/add_variant_to_queue.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Fehler beim Hinzufügen: ' + msg, 'error');
          return;
        }

        const data = await res.json();
        if (!data.ok) {
          showToast('Fehler beim Hinzufügen: ' + (data.error || 'Unknown'), 'error');
          return;
        }

        if (data.already_exists) {
          showToast('Variante bereits in Warteschlange oder vorhanden', 'info');
        } else {
          showToast('Variante zur Warteschlange hinzugefügt. Wird im Hintergrund generiert...', 'success');
        }

        // Update only the affected image row to show the variant in the list
        await updateImageRow(imageBaseName);
        
        // Trigger background tasks after 3 seconds to start processing
        setTimeout(() => {
          if (typeof window.triggerBackgroundTasks === 'function') {
            window.triggerBackgroundTasks();
          }
        }, 3000);
      } catch (error) {
        showToast('Fehler: ' + error.message, 'error');
      } finally {
        thumbElement.style.opacity = prevOpacity || '';
        thumbElement.style.cursor = '';
      }
    }

    async function updateImageRow(imageBaseName, options = {}) {
      // Fetch updated image data
      const { groups } = await fetchImages();
      const updatedGroup = groups.find(g => g.base === imageBaseName);
      
      if (!updatedGroup) {
        // If image not found, do full refresh as fallback
        refresh();
        return;
      }

      // Find the existing row element
      const existingRow = document.getElementById(`painting-${imageBaseName}`);
      if (!existingRow) {
        // If row not found, do full refresh as fallback
        refresh();
        return;
      }

      // Preserve form values to avoid losing user input
      const formContainer = existingRow.querySelector('.form-container');
      const formFields = formContainer ? formContainer.querySelectorAll('input[data-ai-field="true"], textarea[data-ai-field="true"]') : [];
      let preservedFormValues = null;
      if (formFields.length > 0) {
        preservedFormValues = {};
        formFields.forEach(field => {
          if (field.type === 'checkbox') {
            preservedFormValues[field.name] = field.checked;
          } else {
            preservedFormValues[field.name] = field.value;
          }
        });
        // Also preserve frame type
        const frameSelect = formContainer.querySelector('select[name="frame_type"]');
        if (frameSelect) {
          preservedFormValues.frame_type = frameSelect.value;
        }
        // Also preserve sold checkbox
        const soldCheckbox = formContainer.querySelector('input[name="sold"]');
        if (soldCheckbox) {
          preservedFormValues.sold = soldCheckbox.checked;
        }
      }

      // Fetch variants first to ensure they're available
      availableVariants = await fetchVariants();

      // Render the new row
      const newRow = renderImageRow(updatedGroup);
      
      // Restore preserved form values
      if (preservedFormValues) {
        const newFormContainer = newRow.querySelector('.form-container');
        if (newFormContainer) {
          Object.keys(preservedFormValues).forEach(name => {
            const field = newFormContainer.querySelector(`[name="${name}"]`);
            if (field) {
              if (field.type === 'checkbox') {
                field.checked = preservedFormValues[name];
              } else {
                field.value = preservedFormValues[name];
              }
            }
          });
        }
      }
      
      // Replace the old row with the new one
      existingRow.replaceWith(newRow);
      
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;'}[c]));
    }

    function toggleVariants(imageBaseName) {
      const variantsSection = document.getElementById(`selectable-variants-${imageBaseName}`);
      if (variantsSection) {
        variantsSection.classList.toggle('visible');
        // Update URL when interacting with variants
        updatePaintingURL(imageBaseName);
      }
    }

    async function handleBadgeClick(imageOriginalName, isLive) {
      // Extract imageBaseName and update URL
      const base = imageOriginalName.replace(/_variant_[^_]+\.(jpg|jpeg|png)$/i, '').replace(/_(original|color|final)\.(jpg|jpeg|png)$/i, '').replace(/\.(jpg|jpeg|png)$/i, '');
      updatePaintingURL(base);
      
      if (isLive) {
        await removeFromGallery(imageOriginalName, {});
      } else {
        await copyToGallery(imageOriginalName, {});
      }
    }

    function showToast(message, type = 'info', duration = 3000) {
      const container = document.getElementById('toastContainer');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      container.appendChild(toast);
      
      // Limit duration to maximum 20 seconds
      const maxDuration = 20000;
      const actualDuration = Math.min(duration, maxDuration);
      
      setTimeout(() => {
        toast.classList.add('hiding');
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 300);
      }, actualDuration);
    }

    // Image resizing function
    async function resizeImage(file, maxWidth = 2048) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            // Check if resizing is needed
            if (img.width <= maxWidth) {
              resolve(file);
              return;
            }
            
            // Calculate new dimensions
            const ratio = maxWidth / img.width;
            const newWidth = maxWidth;
            const newHeight = Math.round(img.height * ratio);
            
            // Create canvas and resize
            const canvas = document.createElement('canvas');
            canvas.width = newWidth;
            canvas.height = newHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, newWidth, newHeight);
            
            // Convert to blob
            canvas.toBlob((blob) => {
              if (!blob) {
                reject(new Error('Failed to resize image'));
                return;
              }
              // Create a new File object with the same name
              const resizedFile = new File([blob], file.name, {
                type: file.type,
                lastModified: Date.now()
              });
              resolve(resizedFile);
            }, file.type, 0.92); // Use 0.92 quality for JPEG
          };
          img.onerror = () => reject(new Error('Failed to load image'));
          img.src = e.target.result;
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsDataURL(file);
      });
    }

    // Format time duration
    function formatDuration(seconds) {
      if (seconds < 60) {
        return `${Math.round(seconds)}s`;
      }
      const mins = Math.floor(seconds / 60);
      const secs = Math.round(seconds % 60);
      return `${mins}m ${secs}s`;
    }

    window.addEventListener('DOMContentLoaded', () => {
      // showFlashFromQuery(); // Function not defined, commented out
      refresh();
      
      const fileInput = document.getElementById('fileInput');
      const uploadArea = document.getElementById('uploadArea');
      const uploadForm = document.getElementById('uploadForm');
      
      const aiFileInput = document.getElementById('aiFileInput');
      const aiUploadArea = document.getElementById('aiUploadArea');
      const aiUploadForm = document.getElementById('aiUploadForm');
      
      // Function to remove painting parameter from URL
      function removePaintingFromUrl() {
        const url = new URL(window.location);
        url.searchParams.delete('painting');
        url.searchParams.delete('variant');
        window.history.replaceState({}, '', url);
      }
      
      // Regular upload area click handler
      uploadArea.addEventListener('click', () => {
        removePaintingFromUrl();
        fileInput.click();
      });
      
      // AI upload area click handler
      aiUploadArea.addEventListener('click', () => {
        removePaintingFromUrl();
        aiFileInput.click();
      });
      
      // Regular file input change handler
      fileInput.addEventListener('change', async (e) => {
        if (!fileInput.files || fileInput.files.length === 0) return;
        removePaintingFromUrl();
        await uploadFiles(fileInput.files, false);
      }, { passive: true });
      
      // AI file input change handler
      aiFileInput.addEventListener('change', async (e) => {
        if (!aiFileInput.files || aiFileInput.files.length === 0) return;
        removePaintingFromUrl();
        await uploadFiles(aiFileInput.files, true);
      }, { passive: true });
      
      // Regular drag and drop handlers
      uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.add('dragover');
      });
      
      uploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.remove('dragover');
      });
      
      uploadArea.addEventListener('drop', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        uploadArea.classList.remove('dragover');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          removePaintingFromUrl();
          await uploadFiles(files, false);
        }
      });
      
      // AI drag and drop handlers
      aiUploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        aiUploadArea.classList.add('dragover');
      });
      
      aiUploadArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        aiUploadArea.classList.remove('dragover');
      });
      
      aiUploadArea.addEventListener('drop', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        aiUploadArea.classList.remove('dragover');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          removePaintingFromUrl();
          await uploadFiles(files, true);
        }
      });
      
      async function uploadFiles(files, isAIUpload) {
        const startTime = Date.now();
        const progressContainer = isAIUpload ? document.getElementById('aiUploadProgress') : document.getElementById('regularUploadProgress');
        const progressBar = isAIUpload ? document.getElementById('aiUploadProgressBar') : document.getElementById('regularUploadProgressBar');
        const statusText = isAIUpload ? document.getElementById('aiUploadStatus') : document.getElementById('regularUploadStatus');
        const timeText = isAIUpload ? document.getElementById('aiUploadTime') : document.getElementById('regularUploadTime');
        const fileInputElement = isAIUpload ? aiFileInput : fileInput;
        
        // Show progress container
        progressContainer.style.display = 'block';
        progressBar.style.width = '0%';
        statusText.textContent = isAIUpload ? 'Bilder werden vorbereitet...' : 'Bilder werden vorbereitet...';
        
        try {
          // For standard uploads, keep original resolution (no client-side resizing)
          // For AI uploads, resize to avoid server limits
          const filesToUpload = [];
          if (isAIUpload) {
            // Resize images for AI uploads to avoid server limits
            const resizedFiles = [];
            for (let i = 0; i < files.length; i++) {
              statusText.textContent = `Bild ${i + 1}/${files.length} wird vorbereitet...`;
              try {
                const resized = await resizeImage(files[i]);
                resizedFiles.push(resized);
              } catch (error) {
                console.error('Error resizing image:', error);
                // Use original file if resize fails
                resizedFiles.push(files[i]);
              }
            }
            filesToUpload.push(...resizedFiles);
          } else {
            // Standard upload: use original files without resizing
            filesToUpload.push(...files);
          }
          
          // Create FormData
          const fd = new FormData();
          for (let i = 0; i < filesToUpload.length; i++) {
            fd.append('images[]', filesToUpload[i]);
          }
          
          // Add AI upload flag
          if (isAIUpload) {
            fd.append('ai_upload', '1');
          }
          
          // Upload with progress tracking
          statusText.textContent = isAIUpload ? 'Bilder werden hochgeladen...' : 'Bilder werden hochgeladen...';
          progressBar.style.width = '30%';
          
          const xhr = new XMLHttpRequest();
          
          // Track upload progress
          xhr.upload.addEventListener('progress', (e) => {
            if (e.lengthComputable) {
              const percentComplete = 30 + (e.loaded / e.total) * 70; // 30% for prep, 70% for upload
              progressBar.style.width = percentComplete + '%';
            }
          });
          
          // Update time display
          const timeInterval = setInterval(() => {
            const elapsed = (Date.now() - startTime) / 1000;
            timeText.textContent = `Dauer: ${formatDuration(elapsed)}`;
          }, 100);
          
          const uploadPromise = new Promise((resolve, reject) => {
            xhr.onload = () => {
              clearInterval(timeInterval);
              if (xhr.status >= 200 && xhr.status < 300) {
                progressBar.style.width = '100%';
                // Check if response is JSON (AI upload) or redirect (regular upload)
                const contentType = xhr.getResponseHeader('Content-Type') || '';
                if (contentType.includes('application/json') || isAIUpload) {
                  try {
                    // Try to extract JSON from response (in case PHP errors were output first)
                    let responseText = xhr.responseText.trim();
                    // Find JSON object in response (handle PHP warnings before JSON)
                    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                      const data = JSON.parse(jsonMatch[0]);
                      resolve(data);
                    } else {
                      // No JSON found, might be an error
                      reject(new Error('Invalid JSON response: ' + responseText.substring(0, 200)));
                    }
                  } catch (e) {
                    reject(new Error('JSON parse error: ' + e.message + '. Response: ' + xhr.responseText.substring(0, 200)));
                  }
                } else {
                  // Regular upload - redirect response
                  resolve({ ok: true, redirect: true });
                }
              } else {
                // Try to parse error response as JSON
                try {
                  const jsonMatch = xhr.responseText.match(/\{[\s\S]*\}/);
                  if (jsonMatch) {
                    const errorData = JSON.parse(jsonMatch[0]);
                    reject(new Error(errorData.error || `Upload failed: ${xhr.status}`));
                  } else {
                    reject(new Error(`Upload failed: ${xhr.status}. Response: ${xhr.responseText.substring(0, 200)}`));
                  }
                } catch (e) {
                  reject(new Error(`Upload failed: ${xhr.status}`));
                }
              }
            };
            xhr.onerror = () => {
              clearInterval(timeInterval);
              reject(new Error('Upload failed - network error'));
            };
            xhr.open('POST', 'upload.php');
            xhr.send(fd);
          });
          
          const response = await uploadPromise;
          const elapsed = (Date.now() - startTime) / 1000;
          timeText.textContent = `Abgeschlossen in ${formatDuration(elapsed)}`;
          
          if (isAIUpload) {
            // Parse response to get uploaded image names
            if (response.ok && response.uploaded_images && response.uploaded_images.length > 0) {
              // Show warning if images were resized
              if (response.resized_images && response.resized_images.length > 0) {
                const resizedCount = response.resized_images.length;
                showToast(`⚠️ Warnung: ${resizedCount} Bild(er) wurden vom Server automatisch verkleinert, da die Originalgröße zu groß war.`, 'error', 8000);
              }
              // Process each uploaded image with AI
              await processAIImageWorkflow(response.uploaded_images, startTime);
            } else {
              showToast('Upload erfolgreich, aber AI-Verarbeitung konnte nicht gestartet werden', 'error');
              refresh();
            }
          } else {
            // Check if response contains resized_images info (for standard uploads via redirect)
            // The redirect will handle showing the flash message
            showToast(`${files.length} Bild(er) erfolgreich hochgeladen`, 'success');
            fileInputElement.value = '';
            setTimeout(() => {
              progressContainer.style.display = 'none';
            }, 2000);
            refresh();
          }
          } catch (error) {
            console.error('Upload error:', error);
            showToast('Fehler beim Hochladen: ' + error.message, 'error');
            progressContainer.style.display = 'none';
            // Still refresh to show uploaded images even if workflow failed
            if (isAIUpload) {
              refresh();
            }
          }
      }
      
      async function processAIImageWorkflow(uploadedImages, startTime) {
        const step1 = document.getElementById('aiStep1');
        const step2 = document.getElementById('aiStep2');
        const step3 = document.getElementById('aiStep3');
        const step4 = document.getElementById('aiStep4');
        const progressBar = document.getElementById('aiUploadProgressBar');
        const statusText = document.getElementById('aiUploadStatus');
        const timeText = document.getElementById('aiUploadTime');
        
        // Update time display continuously
        const timeInterval = setInterval(() => {
          const elapsed = (Date.now() - startTime) / 1000;
          timeText.textContent = `Dauer: ${formatDuration(elapsed)}`;
        }, 100);
        
        // Process each image sequentially
        for (let i = 0; i < uploadedImages.length; i++) {
          const imageName = uploadedImages[i];
          const imageBase = imageName.replace(/_original\.(jpg|jpeg|png)$/i, '');
          
          // Calculate progress: upload is 25%, each image processing is 75% / (images * steps)
          const baseProgress = 25;
          const progressPerImage = 75 / uploadedImages.length;
          const progressPerStep = progressPerImage / 4; // 4 steps per image
          
          try {
            // Step 1: Upload complete
            step1.textContent = `✅ Upload abgeschlossen (${i + 1}/${uploadedImages.length})`;
            step1.style.opacity = '1';
            step2.style.opacity = '0.5';
            step3.style.opacity = '0.5';
            step4.style.opacity = '0.5';
            const imageProgress = baseProgress + (i * progressPerImage);
            progressBar.style.width = imageProgress + '%';
            statusText.textContent = `Bild ${i + 1}/${uploadedImages.length}: KI Bild freistellen lassen...`;
            
            // Step 2: AI flags already set by upload.php (ai_generation_status: 'wanted')
            // Just confirm - no need to wait for processing
            step2.textContent = `✅ KI Verarbeitung geplant (${i + 1}/${uploadedImages.length}) - wird im Hintergrund verarbeitet`;
            step2.style.opacity = '1';
            progressBar.style.width = (imageProgress + progressPerStep * 2) + '%';
            
            // Step 3: Skip form filling - it's already queued via ai_generation_status
            step3.textContent = `⏭ KI Formular ausfüllen übersprungen (wird im Hintergrund verarbeitet) (${i + 1}/${uploadedImages.length})`;
            step3.style.opacity = '0.7';
            progressBar.style.width = (imageProgress + progressPerStep * 3) + '%';
            
            // Step 4: Generate random variant
            step4.textContent = `🔄 KI Variante generieren (${i + 1}/${uploadedImages.length})...`;
            step4.style.opacity = '1';
            statusText.textContent = `Bild ${i + 1}/${uploadedImages.length}: KI Variante generieren...`;
            progressBar.style.width = (imageProgress + progressPerStep * 3.5) + '%';
            
            // Get available variants
            const variantsRes = await fetch('variants.php?action=list');
            if (!variantsRes.ok) {
              throw new Error('Varianten konnten nicht geladen werden');
            }
            
            const variantsData = await variantsRes.json();
            if (!variantsData.ok || !variantsData.variants || variantsData.variants.length === 0) {
              step4.textContent = `⏭ KI Variante übersprungen (keine Varianten verfügbar)`;
              step4.style.opacity = '0.7';
            } else {
              // Pick a random variant
              const randomVariant = variantsData.variants[Math.floor(Math.random() * variantsData.variants.length)];
              
              // Extract variant name from filename
              const variantName = randomVariant.name.replace(/\.(jpg|jpeg)$/i, '');
              
              // Add variant to queue (only updates JSON, doesn't create file yet)
              const variantRes = await fetch('/admin/add_variant_to_queue.php', {
                method: 'POST',
                body: (() => {
                  const fd = new FormData();
                  fd.append('image_base_name', imageBase);
                  fd.append('variant_name', variantName);
                  return fd;
                })()
              });
              
              if (!variantRes.ok) {
                throw new Error('KI Variante zur Warteschlange hinzufügen fehlgeschlagen');
              }
              
              const variantData = await variantRes.json();
              if (!variantData.ok) {
                throw new Error('KI Variante zur Warteschlange hinzufügen fehlgeschlagen: ' + (variantData.error || 'Unknown'));
              }
              
              step4.textContent = `✅ KI Variante zur Warteschlange hinzugefügt (${i + 1}/${uploadedImages.length}) - wird im Hintergrund generiert`;
            }
            
            progressBar.style.width = (imageProgress + progressPerImage) + '%';
            
          } catch (error) {
            console.error('Error processing image:', error);
            showToast(`Fehler bei Bild ${i + 1}: ${error.message}`, 'error');
            // Continue with next image
          }
        }
        
        clearInterval(timeInterval);
        
        // Trigger background tasks after 3 seconds to start processing all queued variants
        setTimeout(() => {
          if (typeof window.triggerBackgroundTasks === 'function') {
            window.triggerBackgroundTasks();
          }
        }, 3000);
        
        // All done
        progressBar.style.width = '100%';
        const elapsed = (Date.now() - startTime) / 1000;
        timeText.textContent = `Abgeschlossen in ${formatDuration(elapsed)}`;
        statusText.textContent = `Alle ${uploadedImages.length} Bild(er) erfolgreich verarbeitet`;
        showToast(`${uploadedImages.length} Bild(er) erfolgreich hochgeladen und verarbeitet`, 'success');
        
        aiFileInput.value = '';
        setTimeout(() => {
          document.getElementById('aiUploadProgress').style.display = 'none';
        }, 5000);
        refresh();
      }
    });
  </script>
  <noscript>Please enable JavaScript to view and select images.</noscript>
  <meta name="robots" content="noindex, nofollow">
  <meta http-equiv="Cache-Control" content="no-store" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <link rel="icon" href="data:,">
  <title>Administration der Herzfabrik</title>
  </head>
<body>
  <div id="toastContainer" class="toast-container"></div>
  <div class="header-container">
    <h1 class="header-title">Administration der <a href="/index.html" id="site-domain-link" class="site-domain-link">Herzfabrik</a></h1>
    <div class="nav-container">
      <a href="index.html" class="nav-link active">Gemälde</a>
      <a href="variants.html" class="nav-link">Raum-Mockups</a>
      <a href="artist.html" class="nav-link">Künstler</a>
      <button id="bgTasksBtn" title="Background Tasks">0</button>
    </div>
  </div>
  <div id="flash" class="flash hidden"></div>

  <div class="">
    <h2>Gemälde hochladen</h2>
    <div class="upload-sections upload-sections-grid">
      <!-- Regular Upload Section -->
      <div>
        <h3 class="upload-section-title">Standard Upload</h3>
        <form id="uploadForm" action="/admin/upload.php" method="post" enctype="multipart/form-data">
          <div id="uploadArea" class="upload-area">
            <div class="upload-area-text">📷 Bilder hier ablegen oder klicken zum Auswählen</div>
            <div class="upload-area-hint">Sie können mehrere Bilder gleichzeitig hochladen</div>
            <input type="file" name="images[]" accept="image/*" multiple required class="file-input-hidden" id="fileInput">
          </div>
        </form>
        <div id="regularUploadProgress" class="progress-container">
          <div class="progress-status">
            <span id="regularUploadStatus">Wird hochgeladen...</span>
            <span id="regularUploadTime" class="progress-status-time"></span>
          </div>
          <div class="progress-bar-container">
            <div id="regularUploadProgressBar" class="progress-bar"></div>
          </div>
        </div>
      </div>
      
      <!-- AI Upload Section -->
      <div>
        <h3 class="upload-section-title">
          <span class="star-icon">⭐</span> KI Upload (Automatische Verarbeitung)
        </h3>
        <form id="aiUploadForm" action="/admin/upload.php" method="post" enctype="multipart/form-data">
          <div id="aiUploadArea" class="upload-area upload-area-ai">
            <div class="upload-area-text">⭐ KI Bilder hier ablegen oder klicken</div>
            <div class="upload-area-hint">Automatische Verarbeitung: Freistellen → Formular → Variante</div>
            <input type="file" name="images[]" accept="image/*" multiple required class="file-input-hidden" id="aiFileInput">
          </div>
        </form>
        <div id="aiUploadProgress" class="progress-container">
          <div class="progress-status">
            <div id="aiUploadStatus">Wird hochgeladen...</div>
            <div id="aiUploadTime" class="progress-status-time-mt"></div>
          </div>
          <div class="progress-bar-container-mb">
            <div id="aiUploadProgressBar" class="progress-bar-ai"></div>
          </div>
          <div id="aiStepsProgress" class="ai-steps-progress">
            <div id="aiStep1" class="ai-step">⏳ Warte auf Upload...</div>
            <div id="aiStep2" class="ai-step ai-step-opacity">⏸ KI Bild freistellen lassen</div>
            <div id="aiStep3" class="ai-step ai-step-opacity">⏸ KI Formular ausfüllen lassen</div>
            <div id="aiStep4" class="ai-step-last">⏸ KI Variante generieren</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="">
    <div class="toolbar">
      <h2>Gemälde</h2>
    </div>
    <div id="images" class="list"></div>
  </div>

  <script>
    function showFlashFromQuery() {
      const url = new URL(window.location.href);
      const uploaded = url.searchParams.get('uploaded');
      const errors = url.searchParams.get('errors');
      const resized = url.searchParams.get('resized');
      const errorsDetailRaw = url.searchParams.get('errors_detail');
      
      if (!uploaded && !errors && !resized) return;
      
      const box = document.getElementById('flash');
      box.classList.remove('hidden');
      const u = parseInt(uploaded || '0', 10);
      const e = parseInt(errors || '0', 10);
      const r = parseInt(resized || '0', 10);
      let html = '';
      
      if (e > 0) {
        box.classList.remove('success');
        html += `<strong>Upload finished:</strong> ${u} succeeded, ${e} failed.`;
        if (errorsDetailRaw) {
          try {
            const details = JSON.parse(errorsDetailRaw);
            if (Array.isArray(details) && details.length) {
              html += '<div class="flash-error-list"><strong>Errors:</strong><ul>' +
                details.map(d => `<li>${String(d)}</li>`).join('') + '</ul></div>';
            }
          } catch {}
        }
      } else if (u > 0) {
        box.classList.add('success');
        html += `<strong>Success:</strong> ${u} Bild(er) erfolgreich hochgeladen.`;
        
        // Show warning if images were resized
        if (r > 0) {
          html += `<div class="flash-warning">
            <strong>⚠️ Warnung:</strong> ${r} Bild(er) wurden vom Server automatisch verkleinert, da die Originalgröße zu groß war. 
            Die _original Version entspricht nicht mehr dem hochgeladenen Bild.
          </div>`;
        }
      }
      
      box.innerHTML = html;
      // Clean params from URL without reloading
      window.history.replaceState({}, '', url.pathname);
    }

    async function saveMeta(image, btn) {
      const item = btn.closest('.rowItem');
      const body = new FormData();
      body.set('image', image);
      body.set('title', item.querySelector('input[name=\"title\"]').value);
      body.set('description', item.querySelector('textarea[name=\"description\"]').value);
      body.set('width', item.querySelector('input[name=\"width\"]').value);
      body.set('height', item.querySelector('input[name=\"height\"]').value);
      body.set('tags', item.querySelector('input[name=\"tags\"]').value);
      body.set('date', item.querySelector('input[name=\"date\"]').value);
      const soldCheckbox = item.querySelector('input[name=\"sold\"]');
      body.set('sold', soldCheckbox && soldCheckbox.checked ? '1' : '0');
      btn.disabled = true;
      const res = await fetch('meta.php', { method: 'POST', body });
      btn.disabled = false;
      if (!res.ok) {
        showToast('Fehler beim Speichern der Metadaten', 'error');
        return;
      }
      const data = await res.json().catch(() => ({}));
      if (data.in_gallery) {
        showToast('Metadaten gespeichert und Live-Version aktualisiert', 'success');
        // Refresh to update button state
        refresh();
      } else {
        showToast('Metadaten gespeichert', 'success');
      }
    }

    async function doAction(image, action, btn) {
      // Extract imageBaseName and update URL
      const row = btn.closest ? btn.closest('.rowItem') : null;
      const imageBaseName = row ? row.dataset.paintingBase : null;
      if (imageBaseName) {
        updatePaintingURL(imageBaseName);
      }
      
      if (btn.disabled !== undefined) {
        btn.disabled = true;
      } else {
        btn.classList.add('loading');
      }
      const prevText = btn.textContent;
      if (action === 'restore' && btn.textContent !== undefined) {
        btn.textContent = 'Wird kopiert…';
      }
      
      const body = new FormData();
      body.set('image', image);
      body.set('action', action);
      
      try {
        const res = await fetch('action.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Fehler: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('Fehler: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        
        if (action === 'restore') {
          showToast('Originalbild wird geladen…', 'info');
          
          // Extract base name: remove _original, _color, _final, or _variant_* suffix and extension
          const base = image.replace(/_variant_[^_]+\.(jpg|jpeg|png)$/i, '').replace(/_(original|color|final)\.(jpg|jpeg|png)$/i, '').replace(/\.(jpg|jpeg|png)$/i, '');
          
          // Wait a bit for the file copy operation to complete on the server
          await new Promise(resolve => setTimeout(resolve, 300));
          
          // Update only the affected image row instead of full page reload
          await updateImageRow(base);
          
          // Wait for the DOM to be updated
          await new Promise(resolve => setTimeout(resolve, 50));
          
          // Find the main image and wait for it to load
          const mainImg = document.getElementById(`main-img-${base}`);
          if (mainImg) {
            // Show loading state
            mainImg.style.opacity = '0.5';
            mainImg.style.transition = 'opacity 0.3s ease';
            
            // Get the base URL without query string
            const baseUrl = mainImg.src.split('?')[0];
            const freshUrl = baseUrl + '?t=' + Date.now();
            
            // Preload the image to ensure it's ready before showing it
            await new Promise((resolve) => {
              // Check if image is already complete
              if (mainImg.complete && mainImg.naturalWidth > 0) {
                // Image is already loaded, just update src and show
                mainImg.src = freshUrl;
                mainImg.style.opacity = '1';
                showToast('Originalbild erfolgreich verwendet', 'success');
                resolve();
                return;
              }
              
              // Preload the image
              const img = new Image();
              img.onload = () => {
                // Image is loaded, now update the displayed image
                mainImg.src = freshUrl;
                mainImg.style.opacity = '1';
                showToast('Originalbild erfolgreich verwendet', 'success');
                resolve();
              };
              img.onerror = () => {
                // Retry once after a short delay
                setTimeout(() => {
                  const retryImg = new Image();
                  retryImg.onload = () => {
                    mainImg.src = freshUrl;
                    mainImg.style.opacity = '1';
                    showToast('Originalbild erfolgreich verwendet', 'success');
                    resolve();
                  };
                  retryImg.onerror = () => {
                    mainImg.style.opacity = '1';
                    showToast('Originalbild verwendet, aber Bild konnte nicht geladen werden. Bitte Seite aktualisieren.', 'error');
                    resolve(); // Still resolve to not block
                  };
                  retryImg.src = freshUrl;
                }, 500);
              };
              img.src = freshUrl;
            });
          } else {
            // Fallback: full refresh if image element not found
            await refresh();
            showToast('Originalbild erfolgreich verwendet', 'success');
          }
        } else {
          await refresh();
        }
      } finally {
        if (btn.disabled !== undefined) {
          btn.disabled = false;
        } else {
          btn.classList.remove('loading');
        }
        if (btn.textContent !== undefined) btn.textContent = prevText;
      }
    }

    async function doCorners(imageOriginalName, btn) {
      // Extract imageBaseName and update URL
      const row = btn.closest ? btn.closest('.rowItem') : null;
      const imageBaseName = row ? row.dataset.paintingBase : null;
      if (imageBaseName) {
        updatePaintingURL(imageBaseName);
      }
      
      const prev = btn.textContent;
      if (btn.disabled !== undefined) {
        btn.disabled = true;
      } else {
        btn.classList.add('loading');
      }
      if (btn.textContent !== undefined) btn.textContent = 'KI…';
      try {
        const body = new FormData();
        body.set('image_path', 'admin/images/' + imageOriginalName);
        // Optional: allow offset to be passed (defaults to 1.0 in the PHP script)
        if (row) {
          const offsetInput = row.querySelector('#offsetInput');
          if (offsetInput && offsetInput.value) {
            body.set('offset', offsetInput.value);
          }
        }
        
        // Increase timeout for long-running requests (10 minutes)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 600000); // 10 minutes
        
        const res = await fetch('ai_image_by_corners.php', { 
          method: 'POST', 
          body,
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!res.ok) {
          const msg = await res.text();
          showToast('KI-Verarbeitung fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('KI-Verarbeitung fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        // Extract base name: remove _original, _color, _final, or _variant_* suffix and extension
        const base = imageOriginalName.replace(/_variant_[^_]+\.(jpg|jpeg|png)$/i, '').replace(/_(original|color|final)\.(jpg|jpeg|png)$/i, '').replace(/\.(jpg|jpeg|png)$/i, '');
        await refresh();
        // Force reload the main image after refresh with a small delay to ensure DOM is ready
        setTimeout(() => {
          const mainImg = document.getElementById(`main-img-${base}`);
          if (mainImg) {
            // Force reload by adding/updating cache-busting parameter
            const currentSrc = mainImg.src;
            const separator = currentSrc.includes('?') ? '&' : '?';
            mainImg.src = currentSrc.split('?')[0] + separator + 't=' + Date.now();
          }
        }, 100);
        
        // Trigger background tasks after 3 seconds to process any pending work
        setTimeout(() => {
          if (typeof window.triggerBackgroundTasks === 'function') {
            window.triggerBackgroundTasks();
          }
        }, 3000);
      } catch (error) {
        if (error.name === 'AbortError') {
          showToast('Anfrage wurde abgebrochen oder dauerte zu lange. Der Prozess läuft möglicherweise im Hintergrund weiter.', 'error');
        } else {
          showToast('Fehler bei KI-Verarbeitung: ' + (error.message || 'Unknown error'), 'error');
        }
      } finally {
        if (btn.disabled !== undefined) {
          btn.disabled = false;
        } else {
          btn.classList.remove('loading');
        }
        if (btn.textContent !== undefined) btn.textContent = prev;
      }
    }

    function doManualFree(imageOriginalName, btn) {
      // Extract base name: remove _original, _color, _final, or _variant_* suffix and extension
      const base = imageOriginalName.replace(/_variant_[^_]+\.(jpg|jpeg|png)$/i, '').replace(/_(original|color|final)\.(jpg|jpeg|png)$/i, '').replace(/\.(jpg|jpeg|png)$/i, '');
      window.location.href = `free.html?painting=${encodeURIComponent(base)}`;
    }

    async function fillFormWithAI(imageOriginalName, btn) {
      const prev = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'KI…';
      
      // Disable button and show loading state
      const originalText = btn.innerHTML;
      btn.innerHTML = '<span class="star-icon">✨</span><span class="short-text">KI arbeitet...</span><span class="full-text">KI analysiert Bild (kann einige Minuten dauern)...</span>';
      
      try {
        const item = btn.closest('.rowItem');
        const imageBaseName = item ? item.dataset.paintingBase : null;
        if (imageBaseName) {
          updatePaintingURL(imageBaseName);
        }
        
        // Find the final image URL to log
        const mainImg = item.querySelector('.main-image');
        const imageUrl = mainImg ? mainImg.src : 'images/' + imageOriginalName;
        console.log('KI Formular ausfüllen: Verwende Bild:', imageUrl);
        
        const body = new FormData();
        body.set('image', imageOriginalName);
        
        // Just set the flag - don't wait for AI processing
        const res = await fetch('/admin/set_ai_form_flag.php', { 
          method: 'POST', 
          body
        });
        
        if (!res.ok) {
          const msg = await res.text();
          showToast('Flag setzen fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('Flag setzen fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
      
        showToast('KI-Formularausfüllung wurde zur Warteschlange hinzugefügt. Wird im Hintergrund verarbeitet.', 'success');
        
        // Immediately update the row to show the overlay
        if (imageBaseName && typeof window.updateImageRow === 'function') {
          await window.updateImageRow(imageBaseName);
        }
        
        // Trigger background tasks after 3 seconds to start processing
        setTimeout(() => {
          if (typeof window.triggerBackgroundTasks === 'function') {
            window.triggerBackgroundTasks();
          }
        }, 3000);
      } catch (error) {
        console.error('Error in fillFormWithAI:', error);
        if (error.name === 'AbortError') {
          showToast('Anfrage wurde abgebrochen oder dauerte zu lange. Der Prozess läuft möglicherweise im Hintergrund weiter.', 'error');
        } else {
          showToast('Fehler bei KI-Formularausfüllung: ' + (error.message || 'Unknown error'), 'error');
        }
      } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
      }
    }

    async function copyToGallery(imageOriginalName, btn) {
      const prev = btn.textContent;
      if (btn.disabled !== undefined) btn.disabled = true;
      if (btn.textContent !== undefined) btn.textContent = 'Schalte live…';
      try {
        const body = new FormData();
        body.set('image', imageOriginalName);
        const res = await fetch('copy_to_gallery.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Live schalten fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('Live schalten fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        showToast('Erfolgreich live geschaltet', 'success');
        refresh();
      } finally {
        if (btn.disabled !== undefined) btn.disabled = false;
        if (btn.textContent !== undefined) btn.textContent = prev;
      }
    }

    async function removeFromGallery(imageOriginalName, btn) {
      const prev = btn.textContent;
      if (btn.disabled !== undefined) btn.disabled = true;
      if (btn.textContent !== undefined) btn.textContent = 'Entferne live…';
      try {
        const body = new FormData();
        body.set('image', imageOriginalName);
        const res = await fetch('remove_from_gallery.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Live entfernen fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('Live entfernen fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        showToast('Erfolgreich live entfernt', 'success');
        refresh();
      } finally {
        if (btn.disabled !== undefined) btn.disabled = false;
        if (btn.textContent !== undefined) btn.textContent = prev;
      }
    }

    async function deleteCompletely(imageOriginalName, btn) {
      if (!confirm('Möchten Sie wirklich alle Dateien dieses Gemäldes löschen? Dies kann nicht rückgängig gemacht werden.')) {
        return;
      }
      const prev = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Lösche…';
      try {
        const body = new FormData();
        body.set('image', imageOriginalName);
        const res = await fetch('delete_completely.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Löschen fehlgeschlagen: ' + msg, 'error');
          return;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('Löschen fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }
        showToast('Alle Dateien erfolgreich gelöscht', 'success');
        refresh();
      } finally {
        btn.disabled = false;
        btn.textContent = prev;
      }
    }

    async function rotateImage(finalImageName, imageBaseName, btn) {
      // Extract imageBaseName and update URL
      updatePaintingURL(imageBaseName);
      
      const prevOpacity = btn.style.opacity;
      btn.style.opacity = '0.5';
      btn.style.cursor = 'wait';
      showToast('Bild wird gedreht...', 'info');

      try {
        // Get the row to check if image is live and get original image name
        const row = document.getElementById(`painting-${imageBaseName}`);
        const isLive = row && row.dataset.paintingInGallery === 'true';
        let originalImageName = null;
        
        if (row && row.dataset.variants) {
          try {
            const variants = JSON.parse(row.dataset.variants);
            const originalVariant = variants.find(v => v.variant === 'original');
            if (originalVariant) {
              originalImageName = originalVariant.name;
            }
          } catch (e) {
            console.error('Error parsing variants:', e);
          }
        }

        const body = new FormData();
        body.set('image', finalImageName);

        const res = await fetch('rotate_image.php', { method: 'POST', body });
        if (!res.ok) {
          const msg = await res.text();
          showToast('Drehen fehlgeschlagen: ' + msg, 'error');
          return;
        }

        const data = await res.json().catch(() => ({}));
        if (!data.ok) {
          showToast('Drehen fehlgeschlagen: ' + (data.error || 'Unknown'), 'error');
          return;
        }

        // If image is live, update the gallery
        if (isLive && originalImageName) {
          showToast('Bild gedreht. Aktualisiere Live-Version...', 'info');
          try {
            const copyBody = new FormData();
            copyBody.set('image', originalImageName);
            const copyRes = await fetch('copy_to_gallery.php', { method: 'POST', body: copyBody });
            if (!copyRes.ok) {
              const copyMsg = await copyRes.text();
              showToast('Bild gedreht, aber Live-Aktualisierung fehlgeschlagen: ' + copyMsg, 'error');
              // Still update the UI even if copy failed
              await updateImageRow(imageBaseName);
              return;
            }
            const copyData = await copyRes.json().catch(() => ({}));
            if (!copyData.ok) {
              showToast('Bild gedreht, aber Live-Aktualisierung fehlgeschlagen: ' + (copyData.error || 'Unknown'), 'error');
              // Still update the UI even if copy failed
              await updateImageRow(imageBaseName);
              return;
            }
            showToast('Bild erfolgreich gedreht und Live-Version aktualisiert', 'success');
          } catch (copyError) {
            showToast('Bild gedreht, aber Live-Aktualisierung fehlgeschlagen: ' + copyError.message, 'error');
            // Still update the UI even if copy failed
            await updateImageRow(imageBaseName);
            return;
          }
        } else {
          showToast('Bild erfolgreich gedreht und Thumbnails aktualisiert', 'success');
        }
        
        // Update only the affected image row instead of full page reload
        await updateImageRow(imageBaseName);
      } catch (error) {
        showToast('Fehler: ' + error.message, 'error');
      } finally {
        btn.style.opacity = prevOpacity || '';
        btn.style.cursor = '';
      }
    }

    function openOriginalImage(originalImageName) {
      // Find the button that was clicked to get the row
      const btn = event.target.closest('.image-control-btn');
      const row = btn ? btn.closest('.rowItem') : null;
      const imageBaseName = row ? row.dataset.paintingBase : null;
      
      if (imageBaseName) {
        updatePaintingURL(imageBaseName);
      }
      
      // Open original image in new tab (not thumbnail)
      const originalUrl = 'images/' + encodeURIComponent(originalImageName);
      window.open(originalUrl, '_blank');
    }

    function openFinalImage(finalImageName) {
      // Find the button that was clicked to get the row
      const btn = event.target.closest('.image-control-btn');
      const row = btn ? btn.closest('.rowItem') : null;
      const imageBaseName = row ? row.dataset.paintingBase : null;
      
      if (imageBaseName) {
        updatePaintingURL(imageBaseName);
      }
      
      // Open final image in new tab (not thumbnail)
      const finalUrl = 'images/' + encodeURIComponent(finalImageName);
      window.open(finalUrl, '_blank');
    }
    
    // Update site domain link in header
    async function updateSiteDomainLink() {
      try {
        const res = await fetch('get_artist_content.php');
        if (!res.ok) return;
        const data = await res.json();
        if (data.ok && data.domain) {
          const domainLink = document.getElementById('site-domain-link');
          if (domainLink) {
            // Capitalize first letter
            const domainText = data.domain.charAt(0).toUpperCase() + data.domain.slice(1);
            domainLink.textContent = domainText;
          }
        }
      } catch (error) {
        // Silently fail - keep default "Herzfabrik"
      }
    }
    
    // Update domain link on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', updateSiteDomainLink);
    } else {
      updateSiteDomainLink();
    }
    async function updateAIStatus(imageOriginalName, statusKey, statusValue, imageBaseName) {
      const body = new FormData();
      body.set('image', imageOriginalName);
      body.set(statusKey, statusValue || '');
      
      try {
        const res = await fetch('meta.php', { method: 'POST', body });
        if (!res.ok) {
          showToast('Fehler beim Aktualisieren des Status', 'error');
          // Reload to restore previous value
          await updateImageRow(imageBaseName);
          return;
        }
        
        showToast('Status aktualisiert', 'success');
        // Reload to show updated status
        await updateImageRow(imageBaseName);
      } catch (error) {
        console.error('Error updating AI status:', error);
        showToast('Fehler beim Aktualisieren des Status', 'error');
        // Reload to restore previous value
        await updateImageRow(imageBaseName);
      }
    }
    
    async function updateAIPaintingVariantStatus(imageOriginalName, variantKey, statusValue, imageBaseName) {
      const body = new FormData();
      body.set('image', imageOriginalName);
      body.set('ai_painting_variant_key', variantKey);
      body.set('ai_painting_variant_status', statusValue || '');
      
      try {
        const res = await fetch('meta.php', { method: 'POST', body });
        if (!res.ok) {
          showToast('Fehler beim Aktualisieren des Variant-Status', 'error');
          // Reload to restore previous value
          await updateImageRow(imageBaseName);
          return;
        }
        
        showToast('Variant-Status aktualisiert', 'success');
        // Reload to show updated status
        await updateImageRow(imageBaseName);
      } catch (error) {
        console.error('Error updating AI painting variant status:', error);
        showToast('Fehler beim Aktualisieren des Variant-Status', 'error');
        // Reload to restore previous value
        await updateImageRow(imageBaseName);
      }
    }
    
    async function showFullJSON(imageOriginalName, imageBaseName) {
      try {
        const res = await fetch(`/admin/images/${imageOriginalName}.json`);
        if (!res.ok) {
          showToast('Fehler beim Laden des JSON', 'error');
          return;
        }
        
        const json = await res.json();
        const jsonString = JSON.stringify(json, null, 2);
        
        // Create modal
        const modal = document.createElement('div');
        modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';
        
        const content = document.createElement('div');
        content.style.cssText = 'background: #fff; border-radius: 8px; padding: 20px; max-width: 90%; max-height: 90%; overflow: auto; position: relative; box-shadow: 0 4px 20px rgba(0,0,0,0.3);';
        
        const closeBtn = document.createElement('button');
        closeBtn.textContent = '×';
        closeBtn.style.cssText = 'position: absolute; top: 10px; right: 10px; background: #dc3545; color: #fff; border: none; border-radius: 50%; width: 30px; height: 30px; font-size: 20px; cursor: pointer; line-height: 1;';
        closeBtn.onclick = () => modal.remove();
        
        const pre = document.createElement('pre');
        pre.style.cssText = 'font-family: monospace; font-size: 12px; margin: 0; white-space: pre-wrap; word-wrap: break-word;';
        pre.textContent = jsonString;
        
        content.appendChild(closeBtn);
        content.appendChild(pre);
        modal.appendChild(content);
        document.body.appendChild(modal);
        
        // Close on click outside
        modal.onclick = (e) => {
          if (e.target === modal) modal.remove();
        };
      } catch (error) {
        console.error('Error showing JSON:', error);
        showToast('Fehler beim Laden des JSON', 'error');
      }
    }
    
  </script>
  <script src="common.js"></script>
</body>
</html>


